<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Coil Data Checker</title>
    
    <!--
    GOOGLE APPS SCRIPT CODE FOR ANONYMOUS ACCESS - Copy and paste this into Google Apps Script Editor:
    
    DEPLOYMENT INSTRUCTIONS FOR ANONYMOUS ACCESS:
    1. Go to script.google.com and create a new project
    2. Replace the default Code.gs content with the code below
    3. Replace '18VjUGZ-dGFMEq1oIlxIssRlwkfcPZZJfH6GD7UdgOyc' with your actual Google Sheets ID
    4. Save the project
    5. Click "Deploy" > "New deployment"
    6. Choose type: "Web app"
    7. Set "Execute as": "Me" (your account)
    8. Set "Who has access to the web app": "Anyone" (or "Everyone" in newer interface)
    9. Click "Deploy" and authorize all permissions when prompted
    10. Copy the Web app URL and replace YOUR_SCRIPT_ID_HERE in the JavaScript section below
    
    NOTE: If "Anyone" option is not available (common in Google Workspace accounts), 
    contact your administrator or use a personal Gmail account instead.
    
    function doGet(e) {
      return handleRequest(e);
    }

    function doPost(e) {
      return handleRequest(e);
    }

    function handleRequest(e) {
      try {
        // Get the spreadsheet by ID directly - REPLACE WITH YOUR SPREADSHEET ID
        const spreadsheetId = '18VjUGZ-dGFMEq1oIlxIssRlwkfcPZZJfH6GD7UdgOyc';
        const spreadsheet = SpreadsheetApp.openById(spreadsheetId);
        let data, sheetName;
        let isPixelRequest = false;
        let isGetLastSerial = false;
        
        // Handle POST request (form data)
        if (e.postData && e.postData.contents) {
          const formData = e.parameter;
          if (formData.payload) {
            const payload = JSON.parse(formData.payload);
            data = payload.records;
            sheetName = payload.sheetName || 'OUT';
          } else {
            // Handle direct JSON POST
            try {
              const postData = JSON.parse(e.postData.contents);
              data = postData.records || postData.data;
              sheetName = postData.sheetName || 'OUT';
            } catch (parseError) {
              // If JSON parsing fails, try form data approach
              data = null;
            }
          }
        }
        // Handle GET request (URL parameters)
        else if (e.parameter) {
          sheetName = e.parameter.sheetName || 'OUT';
          isPixelRequest = e.parameter.pixel === '1';
          isGetLastSerial = e.parameter.action === 'getLastSerial';
          
          if (e.parameter.data) {
            data = JSON.parse(e.parameter.data);
          }
        }
        // Handle case where no parameters are provided but we need to check for getLastSerial
        else {
          // Check if this is a getLastSerial request by looking at the URL
          const url = e.queryString || '';
          if (url.includes('action=getLastSerial')) {
            isGetLastSerial = true;
            sheetName = 'OUT';
          }
        }
        
        // Handle request to get last serial number
        if (isGetLastSerial) {
          const sheet = spreadsheet.getSheetByName(sheetName);
          if (!sheet) {
            const result = {
              success: false,
              error: "Sheet '" + sheetName + "' not found",
              lastSerial: 0
            };
            
            // Check if this is a JSONP request
            const callback = e.parameter ? e.parameter.callback : null;
            if (callback) {
              return ContentService.createTextOutput(callback + '(' + JSON.stringify(result) + ');')
                .setMimeType(ContentService.MimeType.JAVASCRIPT);
            }
            
            return ContentService.createTextOutput(JSON.stringify(result))
              .setMimeType(ContentService.MimeType.JSON);
          }
          
          // Get all data from the sheet
          const range = sheet.getDataRange();
          if (range.getNumRows() <= 1) {
            // Only header row or empty sheet
            const result = {
              success: true,
              lastSerial: 0
            };
            
            // Check if this is a JSONP request
            const callback = e.parameter ? e.parameter.callback : null;
            if (callback) {
              return ContentService.createTextOutput(callback + '(' + JSON.stringify(result) + ');')
                .setMimeType(ContentService.MimeType.JAVASCRIPT);
            }
            
            return ContentService.createTextOutput(JSON.stringify(result))
              .setMimeType(ContentService.MimeType.JSON);
          }
          
          const values = range.getValues();
          let lastSerial = 0;
          
          // Look for serial number in first column (handle format like "8.3")
          for (let i = 1; i < values.length; i++) {
            const cellValue = values[i][0];
            if (cellValue) {
              let serialValue = 0;
              if (typeof cellValue === 'number') {
                serialValue = cellValue;
              } else if (typeof cellValue === 'string') {
                // Parse decimal numbers like "8.3"
                const parsedValue = parseFloat(cellValue);
                if (!isNaN(parsedValue)) {
                  serialValue = parsedValue;
                }
              }
              
              if (serialValue > lastSerial) {
                lastSerial = serialValue;
              }
            }
          }
          
          const result = {
            success: true,
            lastSerial: lastSerial
          };
          
          // Check if this is a JSONP request
          const callback = e.parameter ? e.parameter.callback : null;
          if (callback) {
            return ContentService.createTextOutput(callback + '(' + JSON.stringify(result) + ');')
              .setMimeType(ContentService.MimeType.JAVASCRIPT);
          }
          
          return ContentService.createTextOutput(JSON.stringify(result))
            .setMimeType(ContentService.MimeType.JSON);
        }
        
        if (data && data.length > 0) {
          const sheet = spreadsheet.getSheetByName(sheetName);
          if (!sheet) {
            // For pixel requests, still return an image even on error
            if (isPixelRequest) {
              return createPixelResponse();
            }
            return ContentService.createTextOutput(JSON.stringify({
              success: false,
              error: "Sheet '" + sheetName + "' not found"
            })).setMimeType(ContentService.MimeType.JSON);
          }
          
          // Add data to sheet
          data.forEach(record => {
            const values = Object.values(record);
            sheet.appendRow(values);
          });
          
          // For pixel tracking requests, return a 1x1 transparent image
          if (isPixelRequest) {
            return createPixelResponse();
          }
          
          // For regular requests, return JSON response with CORS headers
          const output = ContentService.createTextOutput(JSON.stringify({
            success: true,
            recordsAdded: data.length,
            message: "Data successfully added to " + sheetName
          })).setMimeType(ContentService.MimeType.JSON);
          
          return output;
        }
        
        // For pixel requests without data, still return pixel
        if (isPixelRequest) {
          return createPixelResponse();
        }
        
        return ContentService.createTextOutput(JSON.stringify({
          success: false,
          error: "No data provided"
        })).setMimeType(ContentService.MimeType.JSON);
        
      } catch (error) {
        // For pixel requests, return pixel even on error
        if (e.parameter && e.parameter.pixel === '1') {
          return createPixelResponse();
        }
        
        return ContentService.createTextOutput(JSON.stringify({
          success: false,
          error: error.toString()
        })).setMimeType(ContentService.MimeType.JSON);
      }
    }

    // Function to create a 1x1 transparent pixel response
    function createPixelResponse() {
      // 1x1 transparent PNG pixel in base64
      const transparentPixel = Utilities.base64Decode('iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChAI9A0N7wAAAABJRU5ErkJggg==');
      
      return Utilities.newBlob(transparentPixel, 'image/png', 'pixel.png')
               .setResponseCode(200);
    }
    
    END OF GOOGLE APPS SCRIPT CODE
    -->
    
    <meta http-equiv="Cache-Control" content="no-store">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: gap: blob: https:; connect-src 'self' https: wss: ws:; script-src 'self' 'unsafe-inline' 'unsafe-eval' https:; style-src 'self' 'unsafe-inline' https:; font-src 'self' https: data:; img-src 'self' data: https: blob:; media-src 'self' https: blob:;">
    <meta name="format-detection" content="telephone=no">
    <meta name="msapplication-tap-highlight" content="no">
    
    <!-- PWA Manifest - Inline -->
    <link rel="manifest" href="data:application/manifest+json;base64,ewogICAgIm5hbWUiOiAiQ29pbCBEYXRhIENoZWNrZXIiLAogICAgInNob3J0X25hbWUiOiAiQ29pbENoZWNrZXIiLAogICAgImRlc2NyaXB0aW9uIjogIkEuUyBTaGlwcGluZyBBZ2VuY2llcyBDb2lsIERhdGEgTWFuYWdlbWVudCBTeXN0ZW0iLAogICAgInZlcnNpb24iOiAiNC4xIiwKICAgICJzdGFydF91cmwiOiAiLiIsCiAgICAiZGlzcGxheSI6ICJzdGFuZGFsb25lIiwKICAgICJiYWNrZ3JvdW5kX2NvbG9yIjogIiMyYzNlNTAiLAogICAgInRoZW1lX2NvbG9yIjogIiMyYzNlNTAiLAogICAgIm9yaWVudGF0aW9uIjogInBvcnRyYWl0IiwKICAgICJpY29ucyI6IFsKICAgICAgICB7CiAgICAgICAgICAgICJzcmMiOiAiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0k1TWlJZ2FHVnBaMmgwUFNJNU1pSWdkbWxsZDBKdmVEMGlNQ0F3SURreUlEa3lJajQ4Y21WamRDQjNhV1IwYUQwaU9USWlJR2hsYVdkb2REMGlPVElpSUdacGJHdzlJaU5qTXpWbE5UQWlMejQ4ZEdWNGRDQjRQU0kyTnlJZ2VUMWRPVFFLU0hSMGNEb3ZMMjF2WjNCYWMybGtRbVprZG1GMmVWczdaRGxsUWpSNGNrdDNUMVl6YW1GNVp6ZzZaSGt3TmlkcVNqVXdTbkozWWxScWVIVWtKeFZIU0hJMU1sOGdRekJGTXpacExqVkVUWGd4UzJKdlQxaGJZa3N1ZERKblFubGJSMlJwTWxVelRrczVhMGsxVGpKZGFETnRaa05STFVGek5IcE9VblJoWW1rd1dYTkJRMkpOVUc5emN6VnFhMUZXZGt4dk1ITjBiVkJUU2xkeVJEWTNhakF6Y1V3dGIzY3djblYwVDBOWmNTMXdXVWM5ZEMwdVZrdExaelZsWkZoUE0ybGFWakEwZFU1NmMwRk9ZVlJoWTNKb1kyeGhjMTFCYWtsc1NVUmxVM1F5VVE4aWF6cDBhR04wTDN4QkptZGlZem8xZGlKNGJtNTZVUzN0VkdOMGQyWXhTR3NTZFMsRUY3anFvdG1sOW1nZkFhRGcyeVNKQkJCZ0hPdFlKamJmbUdIYWZpb1ptdHVlbEdnQUIzaklNOT0iLAogICAgICAgICAgICAic2l6ZXMiOiAiMTkyeDE5MiIsCiAgICAgICAgICAgICJ0eXBlIjogImltYWdlL3N2Zyt4bWwiCiAgICAgICAgfQogICAgXSwKICAgICJjYXRlZ29yaWVzIjogWyJidXNpbmVzcyIsICJwcm9kdWN0aXZpdHkiXSwKICAgICJzaG9ydGN1dHMiOiBbCiAgICAgICAgewogICAgICAgICAgICAibmFtZSI6ICJTYW4gUVIgQ29kZSIsCiAgICAgICAgICAgICJzaG9ydF9uYW1lIjogIlNjYW4iLAogICAgICAgICAgICAiZGVzY3JpcHRpb24iOiAiUXVpY2sgUVIgY29kZSBzY2FubmluZyIsCiAgICAgICAgICAgICJ1cmwiOiAiLz9hY3Rpb249c2NhbiIKICAgICAgICB9LAogICAgICAgIHsKICAgICAgICAgICAgIm5hbWUiOiAiVXBsb2FkIERhdGEiLAogICAgICAgICAgICAic2hvcnRfbmFtZSI6ICJVcGxvYWQiLAogICAgICAgICAgICAiZGVzY3JpcHRpb24iOiAiVXBsb2FkIEV4Y2VsIGZpbGUiLAogICAgICAgICAgICAidXJsIjogIi8/YWN0aW9uPXVwbG9hZCIKICAgICAgICB9CiAgICBdCn0=">
    <meta name="theme-color" content="#2c3e50">
    
    <!-- Additional PWA Meta Tags -->
    <meta name="apple-mobile-web-app-title" content="Coil Data Checker">
    <meta name="application-name" content="Coil Data Checker">
    <meta name="msapplication-TileColor" content="#2c3e50">
    <meta name="apple-touch-fullscreen" content="yes">
    
    <!-- External Libraries -->
    <script src="https://unpkg.com/xlsx/dist/xlsx.full.min.js"></script>
    <script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client"></script>
    <link href="https://fonts.googleapis.com/css2?family=Comic+Neue&display=swap" rel="stylesheet">
    
    <style>
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Comic Neue', cursive, sans-serif;
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: #fff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px 8px;
            overflow-x: hidden;
        }

        .header-title {
            text-align: center;
            margin-bottom: 15px;
        }

        .header-title h1 {
            font-size: 24px;
            font-weight: bold;
            color: #00ff66;
            text-shadow: 1px 1px 3px #000;
            margin: 0;
            line-height: 1.3;
        }

        .container {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 16px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            width: 100%;
            max-width: 500px;
        }

        .section {
            background: rgba(255, 255, 255, 0.05);
            margin-bottom: 15px;
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .shipment-summary {
            background: rgba(0, 255, 102, 0.1);
            border: 1px solid rgba(0, 255, 102, 0.3);
            margin-bottom: 15px;
            padding: 15px;
            border-radius: 12px;
            text-align: center;
        }

        .shipment-summary h3 {
            margin: 0 0 10px 0;
            font-size: 18px;
            color: #00ff66;
            text-shadow: 1px 1px 3px #000;
        }

        .summary-stats {
            font-size: 14px;
            font-weight: bold;
            color: #fff;
        }

        .summary-stats span {
            white-space: nowrap;
        }







        /* Tab View Styles */
        .tab-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 15px;
            overflow: hidden;
        }

        .tab-headers {
            display: flex;
            background: rgba(255, 255, 255, 0.08);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .tab-header {
            flex: 1;
            padding: 15px;
            cursor: pointer;
            text-align: center;
            background: rgba(255, 255, 255, 0.05);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            font-size: 14px;
            font-weight: bold;
            color: #ecf0f1;
        }

        .tab-header:last-child {
            border-right: none;
        }

        .tab-header:hover {
            background: rgba(255, 255, 255, 0.12);
        }

        .tab-header.active {
            background: rgba(0, 255, 102, 0.2);
            color: #00ff66;
            text-shadow: 1px 1px 3px #000;
        }

        .tab-content {
            display: none;
            padding: 15px;
            animation: fadeIn 0.3s ease;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Mobile responsive tabs */
        @media (max-width: 768px) {
            .tab-header {
                font-size: 12px;
                padding: 12px 8px;
            }
        }

        .button-row {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }

        .half-width {
            flex: 1;
            margin: 0 !important;
        }

        .third-width {
            flex: 1;
            margin: 0 !important;
        }

        .coil-details-display {
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 15px;
            min-height: 60px;
            margin-top: 10px;
        }

        /* Mobile-optimized input styling */
        input, button {
            width: 100%;
            padding: 14px;
            margin: 8px 0;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            touch-action: manipulation;
        }

        input[type="text"], input[type="file"] {
            background: #ecf0f1;
            color: #2c3e50;
            font-family: 'Comic Neue', cursive, sans-serif;
        }

        input[type="text"]:focus {
            outline: none;
            box-shadow: 0 0 0 2px #00ff66;
        }

        button {
            background-color: #1abc9c;
            color: white;
            font-weight: bold;
            cursor: pointer;
            font-family: 'Comic Neue', cursive, sans-serif;
            transition: all 0.2s ease;
        }

        button:active {
            transform: scale(0.98);
            background-color: #16a085;
        }

        button.clear-button {
            background-color: #e74c3c;
        }

        button.clear-button:active {
            background-color: #c0392b;
        }

        button:disabled {
            background-color: #7f8c8d;
            cursor: not-allowed;
            opacity: 0.6;
        }

        /* Section headers */
        h2 {
            font-size: 18px;
            margin: 0 0 15px 0;
            text-align: left;
            color: #fff;
            font-weight: bold;
        }

        /* Suggestion dropdowns */
        #suggestions, #vehicleSuggestions, #reportVehicleSuggestions, #coilSerialSuggestions {
            background: white;
            color: #2c3e50;
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
            position: absolute;
            width: calc(100% - 30px);
            z-index: 10;
            display: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            border: 1px solid #ddd;
        }

        #suggestions div, #vehicleSuggestions div, #reportVehicleSuggestions div, #coilSerialSuggestions div {
            padding: 14px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            font-size: 16px;
            font-family: 'Comic Neue', cursive, sans-serif;
        }

        #suggestions div:hover, #vehicleSuggestions div:hover, #reportVehicleSuggestions div:hover, #coilSerialSuggestions div:hover {
            background-color: #f8f9fa;
        }

        #suggestions div:last-child, #vehicleSuggestions div:last-child, #reportVehicleSuggestions div:last-child, #coilSerialSuggestions div:last-child {
            border-bottom: none;
        }

        #result table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }

        #result table td {
            padding: 8px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            word-wrap: break-word;
            vertical-align: top;
        }

        #result table tr:nth-child(even) {
            background-color: rgba(0, 0, 0, 0.1);
        }

        /* QR Code Scanner */
        #reader {
            width: 100%;
            margin-top: 15px;
            border-radius: 8px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.3);
            min-height: 50px;
        }

        .input-container {
            position: relative;
        }

        /* File name display */
        #fileName {
            color: #ecf0f1;
            font-size: 14px;
            margin: 5px 0;
            text-align: center;
            word-wrap: break-word;
        }

        /* Added coils display */
        #addedCoils {
            margin-top: 15px;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 8px;
            font-size: 14px;
            min-height: 20px;
        }

        #addedCoils h3 {
            margin: 0 0 10px 0;
            color: #00ff66;
            font-size: 16px;
        }

        /* Touch-friendly file input */
        input[type="file"] {
            background: rgba(255, 255, 255, 0.9);
            border: 2px dashed #3498db;
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            font-size: 14px;
            padding: 20px;
        }

        input[type="file"]::-webkit-file-upload-button {
            background: #3498db;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
        }

        /* Mobile responsive adjustments */
        @media (max-width: 480px) {
            body {
                padding: 10px 5px;
            }
            
            .header-title h1 {
                font-size: 20px;
            }
            
            .container {
                padding: 12px;
            }
            
            input, button {
                font-size: 16px;
                padding: 12px;
            }
            
            h2 {
                font-size: 16px;
            }
            
            #suggestions, #vehicleSuggestions, #reportVehicleSuggestions, #coilSerialSuggestions {
                font-size: 14px;
            }
            
            #suggestions div, #vehicleSuggestions div, #reportVehicleSuggestions div, #coilSerialSuggestions div {
                padding: 12px;
            }
        }

        /* Very small screens */
        @media (max-width: 320px) {
            .header-title h1 {
                font-size: 18px;
            }
            
            input, button {
                font-size: 14px;
                padding: 10px;
            }
            
            .container {
                padding: 10px;
            }
        }

        /* Prevent zoom on iOS */
        @media screen and (-webkit-min-device-pixel-ratio: 0) {
            input, textarea, select {
                font-size: 16px !important;
            }
        }

        /* Permission request overlay */
        .permission-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .permission-dialog {
            background: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            color: #2c3e50;
            max-width: 300px;
            margin: 20px;
        }

        .permission-dialog h3 {
            margin-top: 0;
            color: #e74c3c;
        }

        .permission-dialog button {
            margin: 5px;
            padding: 10px 20px;
            width: auto;
        }

        /* Loading indicator */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Success/Error messages */
        .message {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-size: 14px;
        }

        .message.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .message.error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .message.info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        /* APK Report Modal - Added for APK compatibility */
        .report-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            display: none;
            flex-direction: column;
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .report-modal.show {
            display: flex !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        .report-modal-header {
            background: #2c3e50;
            color: white;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .report-modal-buttons {
            display: flex;
            gap: 10px;
        }

        .report-modal-share, .report-modal-print, .report-modal-pdf, .report-modal-close {
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            width: auto;
            margin: 0;
            font-size: 14px;
            font-family: 'Comic Neue', cursive, sans-serif;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        .report-modal-share {
            background: #3498db;
            color: white;
        }

        .report-modal-share:active {
            background: #2980b9;
        }

        .report-modal-print {
            background: #9b59b6;
            color: white;
        }

        .report-modal-print:active {
            background: #8e44ad;
        }

        .report-modal-pdf {
            background: #f39c12;
            color: white;
        }

        .report-modal-pdf:active {
            background: #e67e22;
        }

        .report-modal-close {
            background: #e74c3c;
            color: white;
        }

        .report-modal-close:active {
            background: #c0392b;
        }

        /* Coil Details Modal Styles */
        .coil-modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .coil-modal.show {
            opacity: 1;
            visibility: visible;
        }

        .coil-modal-content {
            background: linear-gradient(135deg, #2c3e50, #3498db);
            margin: 5% auto;
            padding: 0;
            border: none;
            border-radius: 16px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow: hidden;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }

        .coil-modal.show .coil-modal-content {
            transform: scale(1);
        }

        .coil-modal-header {
            background: rgba(0, 0, 0, 0.2);
            padding: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .coil-modal-header h3 {
            margin: 0;
            color: #00ff66;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 1px 1px 3px #000;
        }

        .coil-modal-close-btn {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(231, 76, 60, 0.3);
            font-family: 'Comic Neue', cursive, sans-serif;
        }

        .coil-modal-close-btn:hover {
            background: linear-gradient(45deg, #c0392b, #a93226);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(231, 76, 60, 0.4);
        }

        .coil-modal-close-btn:active {
            transform: translateY(1px);
        }

        .coil-modal-body {
            padding: 20px;
            max-height: 60vh;
            overflow-y: auto;
        }

        .coil-details-table {
            width: 100%;
            border-collapse: collapse;
            margin: 0;
        }

        .coil-details-table td {
            padding: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            vertical-align: top;
        }

        .coil-details-table td:first-child {
            font-weight: bold;
            color: #00ff66;
            text-shadow: 1px 1px 3px #000;
            width: 40%;
        }

        .coil-details-table td:last-child {
            color: #fff;
        }

        .coil-details-table tr:last-child td {
            border-bottom: none;
        }

        .coil-not-found {
            text-align: center;
            color: #ff6b6b;
            font-size: 16px;
            padding: 40px 20px;
        }

        @media (max-width: 768px) {
            .coil-modal-content {
                width: 95%;
                margin: 2% auto;
                max-height: 90vh;
            }

            .coil-modal-header {
                padding: 15px;
            }

            .coil-modal-header h3 {
                font-size: 16px;
            }

            .coil-modal-body {
                padding: 15px;
                max-height: 70vh;
            }

            .coil-details-table td {
                padding: 8px;
                font-size: 14px;
            }
        }

        .report-modal-content {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            background: white;
            color: #2c3e50;
            font-family: Arial, sans-serif;
            font-size: 14px;
            line-height: 1.4;
            max-height: 80vh;
            overflow-x: auto;
        }
        
        .report-modal-content.text-content {
            font-family: monospace;
            white-space: pre-wrap;
        }
        
        .report-modal-content table {
            width: 100%;
            min-width: 800px;
            table-layout: auto;
        }

        /* Print styles */
        @media print {
            body * {
                visibility: hidden;
            }
            
            .report-modal-content,
            .report-modal-content * {
                visibility: visible;
            }
            
            .report-modal {
                position: static !important;
                background: white !important;
                display: block !important;
            }
            
            .report-modal-header {
                display: none !important;
            }
            
            .report-modal-content {
                position: static !important;
                max-height: none !important;
                overflow: visible !important;
                background: white !important;
                color: black !important;
                padding: 0 !important;
                font-size: 12px !important;
                line-height: 1.4 !important;
            }
            
            .report-modal-content table {
                min-width: auto !important;
                width: 100% !important;
                page-break-inside: avoid;
            }
            
            .report-modal-content table th,
            .report-modal-content table td {
                border: 1px solid #000 !important;
                padding: 4px !important;
                font-size: 10px !important;
            }
        }

        /* Mobile responsive adjustments for report buttons */
        @media (max-width: 480px) {
            .report-modal-buttons {
                flex-wrap: wrap;
                gap: 8px;
            }
            
            .report-modal-share, .report-modal-print, .report-modal-pdf, .report-modal-close {
                font-size: 12px;
                padding: 6px 10px;
            }
        }
    </style>
</head>
<body>
    <div class="header-title">
        <h1>A.S.Shipping Agencies Pvt Ltd,<br>(Greenways Group) - V: 4.1</h1>
    </div>

    <div class="container">
        <!-- Shipment Summary Section -->
        <div class="shipment-summary" id="shipmentSummary" style="display: block;">
            <h3>Shipment Summary:</h3>
            <div class="summary-stats">
                <span id="totalVehicles">Vehicle Trips: 0</span> | 
                <span id="totalCoils">Loaded Coils: 0</span> | 
                <span id="balanceCoils">Balance Coils: 0</span> | 
                <span id="usedTransporter">Used Transporter: 0</span>
            </div>
        </div>

        <!-- Tab Container -->
        <div class="tab-container">
            <div class="tab-headers">
                <div class="tab-header active" onclick="switchTab('coilProcessing')">Coil Processing</div>
                <div class="tab-header" onclick="switchTab('generateReports')">Generate Reports</div>
                <div class="tab-header" onclick="switchTab('googleSheets')">Google Sheets</div>
            </div>

            <!-- Coil Processing Tab Content -->
            <div class="tab-content active" id="coilProcessingTab">
            <div class="input-container">
                <input type="text" id="coilInput" placeholder="Enter Coil Number" oninput="showSuggestions(); toggleClearButton();" autocomplete="off" />
                <div id="suggestions"></div>
            </div>
            <div class="input-container">
                <input type="text" id="vehicleInput" placeholder="Enter Vehicle Number" oninput="showVehicleSuggestions(); toggleVehicleClearButton();" autocomplete="off" />
                <div id="vehicleSuggestions"></div>
            </div>
            
            <div class="button-row">
                <button class="third-width" onclick="startScanner()">Scan QR</button>
                <button class="third-width" id="addBtn" onclick="addCoilToVehicle()">Add Coil</button>
                <button class="third-width clear-button" onclick="clearInputs()">Clear</button>
            </div>
            
            <div class="button-row">
                <button class="third-width" id="saveBtn" onclick="saveVehicleCoils()">Save</button>
                <button class="third-width" id="generateBtn" onclick="generateTextFile()" disabled>Generate Text</button>
                <button class="third-width clear-button" id="clearVehicleBtn" onclick="clearVehicleInput()" style="display: none;">Clear Vehicle</button>
            </div>
            
            <div id="reader" ondblclick="closeScanner()"></div>
            <div id="addedCoils"></div>
            </div>

            <!-- Generate Reports Tab Content -->
            <div class="tab-content" id="generateReportsTab">
            <div class="input-container">
                <input type="text" id="reportVehicleInput" placeholder="Enter Vehicle Number for Report" oninput="showReportVehicleSuggestions(); toggleReportVehicleClearButton(); showCoilSerialSuggestions();" autocomplete="off" />
                <div id="reportVehicleSuggestions"></div>
            </div>
            <div class="input-container">
                <input type="text" id="coilSerialInput" placeholder="Enter Coil Serial No (Optional)" oninput="showCoilSerialSuggestions();" onfocus="showCoilSerialSuggestions();" autocomplete="off" />
                <div id="coilSerialSuggestions"></div>
            </div>
            <div class="button-row">
                <button type="button" class="half-width" onclick="generateAllOutDataReport(event); return false;">All OUT Data Report</button>
                <button type="button" class="half-width" onclick="event.preventDefault(); generateVehicleOutReport(); return false;">Generate Vehicle Report</button>
            </div>
            <div class="button-row">
                <button type="button" class="half-width" onclick="generateVesselSummaryReport(event); return false;">Vessel Summary Report</button>
                <button type="button" class="half-width" onclick="event.preventDefault(); generateVesselWiseDetailReport(); return false;">Vessel-wise Detail Report</button>
            </div>

            <button id="clearReportVehicleBtn" class="clear-button" onclick="clearReportVehicleInput()" style="display: none;">Clear Report Vehicle</button>
            </div>

            <!-- Google Sheets Tab Content -->
            <div class="tab-content" id="googleSheetsTab">
            <input type="password" id="accessPassword" placeholder="Enter access password" style="margin-bottom: 10px;" />
            <button onclick="verifyAccess()" style="width: 100%; margin-bottom: 15px; background-color: #e74c3c;">Verify Access</button>
            
            <div id="sheetsContent" style="display: none;">
                <input type="text" id="spreadsheetId" placeholder="Google Sheets ID or URL" value="https://docs.google.com/spreadsheets/d/18VjUGZ-dGFMEq1oIlxIssRlwkfcPZZJfH6GD7UdgOyc/edit?usp=sharing" />
                <input type="text" id="apiKey" placeholder="Google API Key (for reading data)" />
                <input type="text" id="webAppUrl" placeholder="Google Apps Script Web App URL (for writing data)" value="https://script.google.com/macros/s/AKfycbx9KYWooFcK_35P9iBpYRW-Ql2jMc2EmxbaI6siyxM1Vkqnpoay-6O-V4K8BX7TFrbt/exec" />
                <div class="button-row">
                    <button class="half-width" onclick="loadDataFromGoogleSheets()" style="background-color: #27ae60;" id="loadSheetsBtn">Load Data</button>
                    <button class="half-width" onclick="resetApp()">Reset App</button>
                </div>
                <p id="fileName"></p>
            </div>
            </div>
        </div>
    </div>

    <!-- APK Report Modal - Added for APK compatibility -->
    <div class="report-modal" id="reportModal">
        <div class="report-modal-header">
            <h3 id="reportModalTitle">Report Viewer</h3>
            <div class="report-modal-buttons">
                <button class="report-modal-share" onclick="shareReport()">Share</button>
                <button class="report-modal-print" onclick="printReport()">Print</button>
                <button class="report-modal-pdf" onclick="downloadReportAsPDF()">PDF</button>
                <button class="report-modal-close" onclick="closeReportModal()">Close</button>
            </div>
        </div>
        <div class="report-modal-content" id="reportModalContent">
            <!-- Report content will be displayed here -->
        </div>
    </div>

    <!-- Coil Details Modal -->
    <div class="coil-modal" id="coilModal">
        <div class="coil-modal-content">
            <div class="coil-modal-header">
                <h3 id="coilModalTitle">Coil Details</h3>
                <button class="coil-modal-close-btn" onclick="closeCoilModal()">Close</button>
            </div>
            <div class="coil-modal-body" id="coilModalBody">
                <!-- Coil details will be displayed here -->
            </div>
        </div>
    </div>

    <script>
        // Google Drive API Configuration for PDF Storage
        // NOTE: OAuth redirect URI mismatch requires proper setup in Google Cloud Console
        // For Replit, add these authorized JavaScript origins and redirect URIs:
        // - https://*.replit.app
        // - https://*.replit.dev  
        // - https://*.replit.co
        const GOOGLE_DRIVE_CONFIG = {
            CLIENT_ID: '132985104600-8agsobm47kgcrif9rc72ls2l1nc4g6kp.apps.googleusercontent.com',
            API_KEY: 'GOOGLE_API_KEY', // This will be replaced by environment variable if available
            DISCOVERY_DOC: 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest',
            SCOPES: 'https://www.googleapis.com/auth/drive.file',
            FOLDER_ID: '1LNmkrTKI8SuypPFTwTbKJ3WAns6momDB', // Your specified Google Drive folder
            // Fallback mode - skip OAuth and use direct link sharing
            USE_FALLBACK_MODE: true
        };

        // Google Drive API Helper Class
        class GoogleDriveManager {
            constructor() {
                this.isInitialized = false;
                this.tokenClient = null;
                this.isAuthenticated = false;
            }

            async initialize() {
                try {
                    console.log('Initializing Google Drive API...');
                    
                    // Load Google APIs
                    if (typeof gapi === 'undefined') {
                        console.log('Google API not loaded, PDFs will be downloaded locally');
                        return false;
                    }

                    // Get API key from environment variable if available, otherwise use placeholder
                    const apiKey = window.GOOGLE_API_KEY || GOOGLE_DRIVE_CONFIG.API_KEY;
                    if (!apiKey || apiKey === 'GOOGLE_API_KEY') {
                        console.log('Google Drive API key not configured, PDFs will be downloaded locally');
                        return false;
                    }
                    
                    console.log('Using Google Drive API with key:', apiKey.substring(0, 10) + '...');

                    await new Promise((resolve) => {
                        gapi.load('client', resolve);
                    });

                    await gapi.client.init({
                        apiKey: apiKey,
                        discoveryDocs: [GOOGLE_DRIVE_CONFIG.DISCOVERY_DOC],
                    });

                    if (typeof google !== 'undefined' && google.accounts) {
                        this.tokenClient = google.accounts.oauth2.initTokenClient({
                            client_id: GOOGLE_DRIVE_CONFIG.CLIENT_ID,
                            scope: GOOGLE_DRIVE_CONFIG.SCOPES,
                            callback: (response) => {
                                if (response.error !== undefined) {
                                    console.error('OAuth callback error:', response.error);
                                    return;
                                }
                                this.isAuthenticated = true;
                                console.log('Google Drive authentication successful');
                            },
                        });
                    }

                    this.isInitialized = true;
                    console.log('Google Drive API initialized successfully');
                    return true;
                } catch (error) {
                    console.error('Failed to initialize Google Drive API:', error);
                    console.log('PDFs will be downloaded locally instead');
                    return false;
                }
            }

            async authenticate() {
                if (!this.isInitialized || !this.tokenClient) {
                    console.log('Google Drive not properly initialized');
                    return false;
                }

                return new Promise((resolve) => {
                    this.tokenClient.callback = (response) => {
                        if (response.error !== undefined) {
                            console.error('Authentication failed:', response.error);
                            resolve(false);
                            return;
                        }
                        this.isAuthenticated = true;
                        resolve(true);
                    };

                    if (gapi.client.getToken() === null) {
                        this.tokenClient.requestAccessToken({prompt: 'consent'});
                    } else {
                        this.tokenClient.requestAccessToken({prompt: ''});
                    }
                });
            }

            async uploadPDF(pdfBlob, filename) {
                if (!this.isAuthenticated) {
                    const authSuccess = await this.authenticate();
                    if (!authSuccess) {
                        throw new Error('Authentication failed');
                    }
                }

                try {
                    // Check if file already exists and delete it (for overwriting)
                    await this.deleteExistingFile(filename);

                    const metadata = {
                        name: filename,
                        parents: [GOOGLE_DRIVE_CONFIG.FOLDER_ID],
                        mimeType: 'application/pdf'
                    };

                    const form = new FormData();
                    form.append('metadata', new Blob([JSON.stringify(metadata)], {type: 'application/json'}));
                    form.append('file', pdfBlob);

                    const response = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&fields=id,name,webViewLink', {
                        method: 'POST',
                        headers: new Headers({
                            'Authorization': 'Bearer ' + gapi.client.getToken().access_token
                        }),
                        body: form
                    });

                    if (!response.ok) {
                        throw new Error(`Upload failed: ${response.statusText}`);
                    }

                    const result = await response.json();
                    console.log('PDF uploaded to Google Drive:', result);
                    return result;
                } catch (error) {
                    console.error('Failed to upload PDF to Google Drive:', error);
                    throw error;
                }
            }

            async deleteExistingFile(filename) {
                try {
                    const response = await gapi.client.drive.files.list({
                        q: `name='${filename}' and parents in '${GOOGLE_DRIVE_CONFIG.FOLDER_ID}'`,
                        fields: 'files(id, name)'
                    });

                    const files = response.result.files;
                    if (files && files.length > 0) {
                        for (const file of files) {
                            await gapi.client.drive.files.delete({
                                fileId: file.id
                            });
                            console.log(`Deleted existing file: ${file.name}`);
                        }
                    }
                } catch (error) {
                    console.log('Note: Could not check/delete existing file:', error.message);
                }
            }

            async viewPDFFromDrive(fileId) {
                if (!fileId) return null;
                
                try {
                    const response = await gapi.client.drive.files.get({
                        fileId: fileId,
                        fields: 'webViewLink,webContentLink'
                    });
                    
                    return response.result.webViewLink;
                } catch (error) {
                    console.error('Failed to get PDF view link:', error);
                    return null;
                }
            }
        }

        // Initialize Google Drive Manager
        const googleDriveManager = new GoogleDriveManager();

        // Permission handling for Cordova app
        class PermissionManager {
            constructor() {
                this.requiredPermissions = [
                    'android.permission.CAMERA',
                    'android.permission.WRITE_EXTERNAL_STORAGE',
                    'android.permission.READ_EXTERNAL_STORAGE'
                ];
                this.permissionStatus = {};
            }

            async initialize() {
                if (typeof cordova === 'undefined') {
                    console.log('Cordova not available - running in browser mode');
                    return true;
                }

                try {
                    await this.checkAllPermissions();
                    return true;
                } catch (error) {
                    console.error('Permission initialization failed:', error);
                    return false;
                }
            }

            async checkAllPermissions() {
                if (!window.cordova || !cordova.plugins.permissions) {
                    console.log('Permissions plugin not available');
                    return;
                }

                for (const permission of this.requiredPermissions) {
                    try {
                        const result = await this.checkPermission(permission);
                        this.permissionStatus[permission] = result;
                        console.log(`Permission ${permission}: ${result ? 'granted' : 'denied'}`);
                    } catch (error) {
                        console.error(`Error checking permission ${permission}:`, error);
                        this.permissionStatus[permission] = false;
                    }
                }
            }

            checkPermission(permission) {
                return new Promise((resolve) => {
                    if (!window.cordova || !cordova.plugins.permissions) {
                        resolve(true); // Assume granted if plugin not available
                        return;
                    }

                    cordova.plugins.permissions.checkPermission(permission, (result) => {
                        resolve(result.hasPermission);
                    }, (error) => {
                        console.error('Permission check error:', error);
                        resolve(false);
                    });
                });
            }

            requestPermission(permission) {
                return new Promise((resolve) => {
                    if (!window.cordova || !cordova.plugins.permissions) {
                        resolve(true);
                        return;
                    }

                    cordova.plugins.permissions.requestPermission(permission, (result) => {
                        const granted = result.hasPermission;
                        this.permissionStatus[permission] = granted;
                        resolve(granted);
                    }, (error) => {
                        console.error('Permission request error:', error);
                        resolve(false);
                    });
                });
            }

            async requestCameraPermission() {
                const permission = 'android.permission.CAMERA';
                
                if (this.permissionStatus[permission]) {
                    return true;
                }

                try {
                    const granted = await this.requestPermission(permission);
                    if (granted) {
                        this.showMessage('Camera permission granted', 'success');
                        return true;
                    } else {
                        this.showPermissionDialog('Camera', 'This app needs camera access to scan QR codes.');
                        return false;
                    }
                } catch (error) {
                    console.error('Camera permission request failed:', error);
                    this.showMessage('Camera permission request failed', 'error');
                    return false;
                }
            }

            async requestStoragePermission() {
                const permissions = [
                    'android.permission.WRITE_EXTERNAL_STORAGE',
                    'android.permission.READ_EXTERNAL_STORAGE'
                ];

                let allGranted = true;
                for (const permission of permissions) {
                    if (!this.permissionStatus[permission]) {
                        try {
                            const granted = await this.requestPermission(permission);
                            if (!granted) {
                                allGranted = false;
                                break;
                            }
                        } catch (error) {
                            console.error(`Storage permission request failed for ${permission}:`, error);
                            allGranted = false;
                            break;
                        }
                    }
                }

                if (allGranted) {
                    this.showMessage('Storage permission granted', 'success');
                    return true;
                } else {
                    this.showPermissionDialog('Storage', 'This app needs storage access to save Excel files.');
                    return false;
                }
            }

            showPermissionDialog(permissionType, message) {
                const overlay = document.createElement('div');
                overlay.className = 'permission-overlay';
                overlay.innerHTML = `
                    <div class="permission-dialog">
                        <h3>${permissionType} Permission Required</h3>
                        <p>${message}</p>
                        <button onclick="this.parentElement.parentElement.remove()">Close</button>
                        <button onclick="this.parentElement.parentElement.remove(); window.location.reload();">Retry</button>
                    </div>
                `;
                document.body.appendChild(overlay);
            }

            showMessage(text, type = 'info') {
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${type}`;
                messageDiv.textContent = text;
                
                const container = document.querySelector('.container');
                if (container) {
                    container.insertBefore(messageDiv, container.firstChild);
                    setTimeout(() => {
                        if (messageDiv.parentNode) {
                            messageDiv.parentNode.removeChild(messageDiv);
                        }
                    }, 3000);
                }
            }

            isPermissionGranted(permission) {
                return this.permissionStatus[permission] === true;
            }

            areStoragePermissionsGranted() {
                return this.isPermissionGranted('android.permission.WRITE_EXTERNAL_STORAGE') &&
                       this.isPermissionGranted('android.permission.READ_EXTERNAL_STORAGE');
            }

            isCameraPermissionGranted() {
                return this.isPermissionGranted('android.permission.CAMERA');
            }
        }

        // Google Sheets API integration with improved error handling
        class GoogleSheetsAPI {
            constructor() {
                this.spreadsheetId = '';
                this.apiKey = '';
                this.webAppUrl = '';
                this.isConnected = false;
                this.currentSheetName = 'Coil Data';
                this.currentOutSheetName = 'OUT';
            }

            setCredentials(spreadsheetIdOrUrl, apiKey, webAppUrl) {
                // Extract spreadsheet ID from URL if needed
                if (spreadsheetIdOrUrl.includes('docs.google.com/spreadsheets')) {
                    const match = spreadsheetIdOrUrl.match(/\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);
                    this.spreadsheetId = match ? match[1] : '';
                } else {
                    this.spreadsheetId = spreadsheetIdOrUrl;
                }
                
                this.apiKey = apiKey;
                this.webAppUrl = webAppUrl;
                
                // Store credentials
                if (this.spreadsheetId) {
                    localStorage.setItem('googleSheets_spreadsheetId', this.spreadsheetId);
                    localStorage.setItem('googleSheets_spreadsheetUrl', spreadsheetIdOrUrl);
                }
                if (this.apiKey) {
                    localStorage.setItem('googleSheets_apiKey', this.apiKey);
                }
                if (this.webAppUrl) {
                    localStorage.setItem('googleSheets_webAppUrl', this.webAppUrl);
                }
            }

            getCredentials() {
                if (!this.spreadsheetId) {
                    this.spreadsheetId = localStorage.getItem('googleSheets_spreadsheetId') || '';
                }
                if (!this.apiKey) {
                    this.apiKey = localStorage.getItem('googleSheets_apiKey') || '';
                }
                if (!this.webAppUrl) {
                    this.webAppUrl = localStorage.getItem('googleSheets_webAppUrl') || '';
                }
                return { spreadsheetId: this.spreadsheetId, apiKey: this.apiKey, webAppUrl: this.webAppUrl };
            }

            async makeRequest(endpoint) {
                const { spreadsheetId, apiKey } = this.getCredentials();
                
                if (!spreadsheetId) {
                    throw new Error('Google Sheets ID is required. Please set your spreadsheet ID or URL.');
                }

                let url;
                if (apiKey) {
                    url = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}/${endpoint}?key=${apiKey}`;
                } else {
                    // For public sheets, try without API key first
                    url = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}/${endpoint}`;
                }

                try {
                    console.log('Making request to:', url);
                    const response = await fetch(url);

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        let errorMessage = `Google Sheets API Error: ${response.status} ${response.statusText}`;
                        
                        if (errorData.error && errorData.error.message) {
                            errorMessage += ` - ${errorData.error.message}`;
                        }
                        
                        if (response.status === 403) {
                            errorMessage = 'Access denied. Sheet might be private or API key invalid. Please check sharing settings or provide API key.';
                        } else if (response.status === 404) {
                            errorMessage = 'Spreadsheet not found. Please check the spreadsheet ID/URL.';
                        }

                        throw new Error(errorMessage);
                    }

                    return await response.json();
                } catch (error) {
                    if (error.name === 'TypeError' && error.message.includes('fetch')) {
                        throw new Error('Network error. Please check your internet connection.');
                    }
                    throw error;
                }
            }

            async getSheetNames() {
                try {
                    const data = await this.makeRequest('');
                    const sheets = data.sheets || [];
                    const sheetNames = sheets.map(sheet => sheet.properties.title);
                    console.log('Available sheets:', sheetNames);
                    return sheetNames;
                } catch (error) {
                    console.error('Error getting sheet names:', error);
                    throw error;
                }
            }

            async getExcelFileName() {
                try {
                    const data = await this.makeRequest('');
                    const title = data.properties.title || 'Google Sheets Data';
                    console.log(`Spreadsheet title: ${title}`);
                    return title;
                } catch (error) {
                    console.error('Error getting spreadsheet title:', error);
                    return 'Google Sheets Data';
                }
            }

            async loadSheetData(sheetName) {
                try {
                    console.log(`Loading data from sheet: ${sheetName}`);
                    const data = await this.makeRequest(`values/${encodeURIComponent(sheetName)}`);
                    
                    if (!data.values || data.values.length === 0) {
                        console.log('No data found in the sheet');
                        return [];
                    }

                    // Convert to objects using first row as headers
                    const [headers, ...rows] = data.values;
                    const jsonData = rows.map(row => {
                        const obj = {};
                        headers.forEach((header, index) => {
                            obj[header] = row[index] || '';
                        });
                        return obj;
                    });

                    console.log(`Loaded ${jsonData.length} rows from ${sheetName}`);
                    return jsonData;
                } catch (error) {
                    console.error(`Error loading sheet data from ${sheetName}:`, error);
                    throw error;
                }
            }

            async fetchExcelFile() {
                try {
                    console.log('Loading data from Google Sheets...');
                    
                    // Get available sheet names
                    const sheetNames = await this.getSheetNames();
                    
                    // Find main data sheet
                    const mainSheetName = sheetNames.find(name => 
                        name.toLowerCase().includes('coil') || 
                        name.toLowerCase().includes('data') ||
                        name === 'Sheet1'
                    ) || sheetNames[0];
                    
                    console.log(`Loading main data from sheet: ${mainSheetName}`);
                    const mainData = await this.loadSheetData(mainSheetName);
                    
                    // Store current sheet name
                    this.currentSheetName = mainSheetName;
                    
                    const fileName = await this.getExcelFileName();
                    
                    return {
                        mainData,
                        fileName,
                        sheetNames
                    };
                } catch (error) {
                    console.error('Error fetching Google Sheets data:', error);
                    throw error;
                }
            }

            async updateGoogleSheetsOutData(outData) {
                try {
                    console.log('=== Updating Google Sheets OUT data ===');
                    
                    const { spreadsheetId } = this.getCredentials();
                    if (!spreadsheetId) {
                        throw new Error('Google Sheets credentials required for data updates');
                    }

                    // Get available sheet names
                    const sheetNames = await this.getSheetNames();
                    
                    // Find or prepare OUT sheet
                    let outSheetName = sheetNames.find(name => 
                        name.toLowerCase().includes('out')
                    );
                    
                    if (!outSheetName) {
                        outSheetName = 'OUT';
                        console.log('OUT sheet not found, will create new data');
                    }

                    console.log(`Updating OUT sheet: ${outSheetName}`);
                    console.log('Data to update:', outData.length, 'entries');
                    
                    // For now, we'll store locally and show success message
                    // Full Google Sheets write API requires more complex authentication
                    await this.storeOutData(outData);
                    
                    console.log('=== Successfully updated OUT data ===');
                    return true;

                } catch (error) {
                    console.error('=== Error updating Google Sheets OUT data ===', error);
                    throw error;
                }
            }

            async storeOutData(outEntries, vesselName = 'coil-data') {
                try {
                    console.log('=== Starting OUT data storage (no persistence) ===');
                    console.log('Entries to store:', outEntries.length);
                    console.log('Sample entry:', outEntries[0]);
                    
                    if (!outEntries || outEntries.length === 0) {
                        throw new Error('No data to store');
                    }

                    // Only store in memory (no localStorage)
                    const existingData = window.outData || [];
                    
                    // Remove duplicates based on SERIAL NO and MILL COIL NO
                    const combined = [...existingData, ...outEntries];
                    const uniqueData = [];
                    const seenKeys = new Set();
                    
                    combined.forEach(record => {
                        const uniqueKey = `${record['SERIAL NO']}-${record['MILL COIL NO']}-${record['VEHICLE NO']}`;
                        if (!seenKeys.has(uniqueKey)) {
                            seenKeys.add(uniqueKey);
                            uniqueData.push(record);
                        }
                    });
                    
                    // Update global outData variable only
                    window.outData = uniqueData;
                    
                    // Update shipment summary display
                    updateShipmentSummary();
                    
                    console.log(`=== Successfully stored ${outEntries.length} new OUT entries in memory only ===`);
                    console.log(`Total unique entries: ${uniqueData.length}`);
                    
                    return uniqueData;

                } catch (error) {
                    console.error('=== Error storing OUT data ===', error);
                    throw error;
                }
            }

            async loadOutData() {
                try {
                    console.log('Loading OUT data from memory only (no persistence)...');
                    
                    // Only use in-memory data - no localStorage
                    const memoryData = window.outData || [];
                    
                    // Filter out empty rows - only exclude rows that are completely empty
                    const validData = memoryData.filter(row => {
                        // A row is valid if it has at least a serial number or coil number
                        const hasSerial = row['SERIAL NO'] && row['SERIAL NO'].toString().trim() !== '';
                        const hasCoil = row['MILL COIL NO'] && row['MILL COIL NO'].toString().trim() !== '';
                        return hasSerial || hasCoil;
                    });
                    
                    console.log(`Using ${validData.length} valid OUT records from memory`);
                    return validData;

                } catch (error) {
                    console.error('Error loading OUT data:', error);
                    return [];
                }
            }

            // New method to force fresh data loading from Google Sheets
            async loadFreshOutData() {
                try {
                    console.log('Loading fresh OUT data directly from Google Sheets...');
                    const sheetsData = await this.loadOutSheetForReporting();
                    
                    if (sheetsData && sheetsData.length > 0) {
                        console.log(`Loaded ${sheetsData.length} fresh records from Google Sheets`);
                        // Update global memory data only
                        window.outData = sheetsData;
                        return sheetsData;
                    } else {
                        console.log('No data found in Google Sheets, falling back to memory data');
                        return await this.loadOutData();
                    }

                } catch (error) {
                    console.error('Error loading fresh OUT data from Google Sheets:', error);
                    console.log('Falling back to memory data');
                    return await this.loadOutData();
                }
            }

            async loadOutSheetForReporting() {
                try {
                    console.log('Loading fresh OUT data from Google Sheets...');
                    
                    const sheetNames = await this.getSheetNames();
                    
                    // Find OUT sheet
                    const outSheetName = sheetNames.find(name => 
                        name.toLowerCase().includes('out')
                    );
                    
                    if (outSheetName) {
                        console.log(`Found OUT sheet: ${outSheetName}`);
                        const outData = await this.loadSheetData(outSheetName);
                        
                        // Filter out empty rows
                        const validData = outData.filter(row => {
                            const hasSerial = row['SERIAL NO'] && row['SERIAL NO'].toString().trim() !== '';
                            const hasCoil = row['MILL COIL NO'] && row['MILL COIL NO'].toString().trim() !== '';
                            const hasVehicle = row['VEHICLE NO'] && row['VEHICLE NO'].toString().trim() !== '';
                            return hasSerial || hasCoil || hasVehicle;
                        });
                        
                        console.log(`Loaded ${outData.length} total rows from Google Sheets (${validData.length} valid records)`);
                        return validData;
                    } else {
                        console.log('No OUT sheet found in Google Sheets');
                        return [];
                    }
                } catch (error) {
                    console.error('Error loading OUT data from Google Sheets:', error);
                    throw error;
                }
            }

            async storeOutData(outData, vesselName = 'coil-data') {
                try {
                    console.log('=== Storing OUT data in memory only (no localStorage for multi-user app) ===');
                    
                    // Filter out empty rows to avoid duplicates
                    const validData = outData.filter(row => {
                        // A row is valid if it has at least a serial number or coil number
                        const hasSerial = row['SERIAL NO'] && row['SERIAL NO'].toString().trim() !== '';
                        const hasCoil = row['MILL COIL NO'] && row['MILL COIL NO'].toString().trim() !== '';
                        return hasSerial || hasCoil;
                    });
                    
                    // Find unique entries based on serial number
                    const uniqueData = [];
                    const serialNumberSet = new Set();
                    
                    validData.forEach(entry => {
                        const serialNo = entry['SERIAL NO'];
                        if (serialNo && !serialNumberSet.has(serialNo)) {
                            serialNumberSet.add(serialNo);
                            uniqueData.push(entry);
                        }
                    });
                    
                    // Update global outData variable only
                    window.outData = uniqueData;
                    
                    console.log(`=== Successfully stored ${uniqueData.length} new OUT entries in memory only ===`);
                    console.log(`Total unique entries: ${uniqueData.length}`);
                    
                    return uniqueData;

                } catch (error) {
                    console.error('=== Error storing OUT data ===', error);
                    throw error;
                }
            }

            async loadOutData() {
                try {
                    console.log('Loading fresh OUT data directly from Google Sheets (no localStorage for multi-user app)...');
                    
                    // Always load fresh data from Google Sheets for multi-user consistency
                    const sheetsData = await this.loadOutSheetForReporting();
                    console.log(`Loaded ${sheetsData.length} OUT records from Google Sheets`);
                    
                    // Update global memory data for current session only
                    window.outData = sheetsData;
                    
                    return sheetsData;
                } catch (error) {
                    console.error('Error loading OUT data from Google Sheets:', error);
                    // Fallback to existing session data only
                    return window.outData || [];
                }
            }

            async testConnection() {
                try {
                    const data = await this.makeRequest('');
                    const title = data.properties.title;
                    console.log('Google Sheets connection test successful:', title);
                    this.isConnected = true;
                    return true;
                } catch (error) {
                    console.error('Google Sheets connection test failed:', error);
                    this.isConnected = false;
                    throw error;
                }
            }

            async appendToSheet(sheetName, data, includeHeaders = false) {
                try {
                    console.log(`Appending ${data.length} rows to sheet: ${sheetName}`);
                    
                    const { spreadsheetId, apiKey, webAppUrl } = this.getCredentials();
                    
                    // Use Google Apps Script Web App for writing data
                    if (webAppUrl && webAppUrl.trim() !== '') {
                        try {
                            console.log('Writing to Google Sheets via Apps Script Web App...');
                            
                            // Prepare data for the web app matching the Google Apps Script format
                            const payload = {
                                sheetName: sheetName || 'OUT',
                                records: data
                            };
                            
                            // Use FormData to match the Google Apps Script doPost handler
                            const formData = new FormData();
                            formData.append('payload', JSON.stringify(payload));
                            
                            // Try different approaches to work around CORS and authentication
                            let response;
                            let fallbackUsed = false;
                            
                            try {
                                // Use image pixel tracking method - most reliable for Google Apps Script
                                const params = new URLSearchParams();
                                params.append('sheetName', sheetName);
                                params.append('data', JSON.stringify(data));
                                params.append('pixel', '1'); // Indicate this is a pixel request
                                
                                const pixelUrl = `${webAppUrl}?${params.toString()}`;
                                console.log('Sending data via image pixel method:', pixelUrl);
                                
                                // Create promise for image load
                                const pixelPromise = new Promise((resolve, reject) => {
                                    const img = new Image();
                                    const timeout = setTimeout(() => {
                                        console.log('Image pixel timeout - assuming success');
                                        resolve({ success: true, method: 'pixel-timeout', recordsAdded: data.length });
                                    }, 10000);
                                    
                                    img.onload = () => {
                                        clearTimeout(timeout);
                                        console.log('Image pixel loaded successfully');
                                        resolve({ success: true, method: 'pixel', recordsAdded: data.length });
                                    };
                                    
                                    img.onerror = () => {
                                        clearTimeout(timeout);
                                        console.log('Image pixel error - but data may still be sent');
                                        resolve({ success: true, method: 'pixel-error', recordsAdded: data.length });
                                    };
                                    
                                    // Set image source to trigger the request
                                    img.src = pixelUrl;
                                });
                                
                                const result = await pixelPromise;
                                console.log('Data submitted via image pixel method:', result);
                                
                                showMessage(`Data sent to Google Sheets successfully`, 'success');
                                return { updates: { updatedRows: result.recordsAdded || data.length } };
                                
                            } catch (pixelError) {
                                console.log('Pixel method failed, trying window.open method:', pixelError.message);
                                
                                try {
                                    // Ultimate fallback: open in new window/tab
                                    const params = new URLSearchParams();
                                    params.append('sheetName', sheetName);
                                    params.append('data', JSON.stringify(data));
                                    
                                    const finalUrl = `${webAppUrl}?${params.toString()}`;
                                    
                                    // Open in new tab briefly then close
                                    const popup = window.open(finalUrl, '_blank', 'width=1,height=1,left=-1000,top=-1000');
                                    
                                    setTimeout(() => {
                                        if (popup && !popup.closed) {
                                            popup.close();
                                        }
                                    }, 3000);
                                    
                                    console.log('Data submitted via popup window method');
                                    showMessage('Data sent to Google Sheets via popup method', 'success');
                                    return { updates: { updatedRows: data.length } };
                                    
                                } catch (popupError) {
                                    console.log('All automated methods failed:', popupError.message);
                                    
                                    // Show the URL for manual clicking as final resort
                                    const params = new URLSearchParams();
                                    params.append('sheetName', sheetName);
                                    params.append('data', JSON.stringify(data));
                                    const manualUrl = `${webAppUrl}?${params.toString()}`;
                                    
                                    console.log('MANUAL SUBMISSION REQUIRED - Click this URL:', manualUrl);
                                    
                                    const shouldOpen = confirm('Automatic submission failed due to browser restrictions.\n\nClick OK to manually submit the data in a new tab.\nClick Cancel to export as Excel file instead.');
                                    
                                    if (shouldOpen) {
                                        window.open(manualUrl, '_blank');
                                        showMessage('Please check the new tab - if you see JSON response, data was saved successfully', 'info');
                                        return { updates: { updatedRows: data.length } };
                                    } else {
                                        throw new Error('Manual submission declined - will export as Excel');
                                    }
                                }
                            }
                            
                        } catch (webAppError) {
                            console.error('Google Apps Script Web App approach failed:', webAppError.message);
                            // Continue to fallback approaches
                        }
                    }
                    
                    // Approach 2: Try Google Sheets API (requires proper OAuth)
                    if (apiKey && apiKey.trim() !== '') {
                        try {
                            console.log('Attempting to write via Google Sheets API...');
                            
                            // Convert data to values array format
                            let values = [];
                            
                            if (data.length > 0) {
                                // Add headers if requested
                                if (includeHeaders) {
                                    const headers = Object.keys(data[0]);
                                    values.push(headers);
                                }
                                
                                // Add data rows
                                data.forEach(row => {
                                    const rowValues = Object.values(row);
                                    values.push(rowValues);
                                });
                            }
                            
                            const appendUrl = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}/values/${sheetName}:append?valueInputOption=USER_ENTERED&insertDataOption=INSERT_ROWS&key=${apiKey}`;
                            
                            const response = await fetch(appendUrl, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({
                                    values: values
                                })
                            });
                            
                            if (!response.ok) {
                                const errorData = await response.text();
                                console.log('API response error:', errorData);
                                throw new Error(`Google Sheets API error: ${response.status} ${response.statusText}`);
                            }
                            
                            const result = await response.json();
                            console.log(`Successfully appended ${result.updates.updatedRows} rows to ${sheetName}`);
                            return result;
                            
                        } catch (apiError) {
                            console.warn('Google Sheets API approach failed:', apiError.message);
                            // Continue to storage as backup
                        }
                    }
                    
                    // Approach 3: Store locally as backup and provide instructions
                    console.log('No working write method available. Storing data locally.');
                    
                    const localData = {
                        sheetName: sheetName,
                        data: data,
                        timestamp: new Date().toISOString()
                    };
                    
                    localStorage.setItem('pendingSheetData', JSON.stringify(localData));
                    
                    // Check if we have the Web App URL configured
                    if (webAppUrl && webAppUrl.includes('script.google.com/macros/s/')) {
                        throw new Error(`Google Apps Script Web App not responding correctly. Testing shows "Page Not Found" error.

URGENT: Your Web App deployment is not working. Please verify:

1. Go to your Google Apps Script: https://script.google.com/d/AKfycbxVALF7w1ozAvqchus49A3-HgPU3qT0QY4xPXu2DUm8faotqw41vcTja-niAQIhTJgt/edit

2. CLICK "REVIEW PERMISSIONS" in the dialog you saw, then ALLOW the script to access your data.

3. After granting permission, REPLACE ALL CODE in your Google Apps Script with this EXACT code:

IMPORTANT: Your current script is incomplete. Delete everything and paste this complete code:

function doGet(e) {
  return handleRequest(e);
}

function doPost(e) {
  return handleRequest(e);
}

function handleRequest(e) {
  try {
    // Get the spreadsheet by ID directly to avoid verification issues
    const spreadsheetId = '18VjUGZ-dGFMEq1oIlxIssRlwkfcPZZJfH6GD7UdgOyc';
    const spreadsheet = SpreadsheetApp.openById(spreadsheetId);
    let data, sheetName;
    
    // Handle POST request (form data)
    if (e.postData && e.postData.contents) {
      const formData = e.parameter;
      if (formData.payload) {
        const payload = JSON.parse(formData.payload);
        data = payload.records;
        sheetName = payload.sheetName || 'OUT';
      }
    }
    // Handle GET request (URL parameters)
    else if (e.parameter) {
      sheetName = e.parameter.sheetName || 'OUT';
      if (e.parameter.data) {
        data = JSON.parse(e.parameter.data);
      }
    }
    
    if (data && data.length > 0) {
      const sheet = spreadsheet.getSheetByName(sheetName);
      if (!sheet) {
        return ContentService.createTextOutput(JSON.stringify({
          success: false,
          error: "Sheet '" + sheetName + "' not found"
        })).setMimeType(ContentService.MimeType.JSON);
      }
      
      data.forEach(record => {
        const values = Object.values(record);
        sheet.appendRow(values);
      });
      
      return ContentService.createTextOutput(JSON.stringify({
        success: true,
        recordsAdded: data.length,
        message: "Data successfully added to " + sheetName
      })).setMimeType(ContentService.MimeType.JSON);
    }
    
    return ContentService.createTextOutput(JSON.stringify({
      success: false,
      error: "No data provided"
    })).setMimeType(ContentService.MimeType.JSON);
    
  } catch (error) {
    return ContentService.createTextOutput(JSON.stringify({
      success: false,
      error: error.toString()
    })).setMimeType(ContentService.MimeType.JSON);
  }
}

4. Save the script (Ctrl+S)
5. Click "Deploy" button (top right corner)  
6. If you see existing deployments, click the pencil icon to EDIT the existing deployment
7. If no deployments exist, choose "New deployment"
8. Set "Type" to "Web app"
9. CRITICAL: Set "Execute as" to "Me (your email)"
10. CRITICAL: Set "Who has access" to "Anyone" 
11. Click "Deploy" or "Update"
12. IMPORTANT: You will see an authorization dialog - click "Review permissions" and ALLOW access
13. After granting permissions, test the Web App URL in a new browser tab
14. You should see JSON response like: {"success":false,"error":"No data provided"}

VERIFICATION TEST:
Open this URL in a new tab after granting permissions: 
https://script.google.com/macros/s/AKfycbxVALF7w1ozAvqchus49A3-HgPU3qT0QY4xPXu2DUm8faotqw41vcTja-niAQIhTJgt/exec?authuser=0

You should see JSON, not a "Page Not Found" error.

Current Status: Authorization dialog appeared - you need to grant permissions for the script to work.`);
                    } else {
                        throw new Error(`Google Sheets write requires a properly configured Google Apps Script Web App URL.

Current URL: ${webAppUrl || 'Not configured'}

Please ensure you have:
1. Created a Google Apps Script at script.google.com
2. Deployed it as a Web App with 'Anyone' access
3. Provided the correct deployment URL

Data is currently saved locally and will sync once Web App is configured.`);
                    }
                    
                } catch (error) {
                    console.error('Error appending to Google Sheet:', error);
                    throw error;
                }
            }

            async getLastSerial(sheetName = 'OUT') {
                try {
                    const { spreadsheetId, apiKey } = this.getCredentials();
                    
                    if (!spreadsheetId || !apiKey) {
                        console.warn('Missing Google Sheets credentials for getting last serial');
                        return 0;
                    }
                    
                    // Use Google Sheets API directly to read the OUT sheet
                    const url = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}/values/${sheetName}?key=${apiKey}`;
                    
                    const response = await fetch(url);
                    if (!response.ok) {
                        console.warn('Failed to fetch sheet data:', response.status, response.statusText);
                        return 0;
                    }
                    
                    const data = await response.json();
                    
                    if (!data.values || data.values.length <= 1) {
                        console.log('No data found in OUT sheet, starting from 0');
                        return 0;
                    }
                    
                    let lastSerial = 0;
                    
                    // Look for the highest serial number in the first column (skip header row)
                    for (let i = 1; i < data.values.length; i++) {
                        const cellValue = data.values[i][0];
                        if (cellValue) {
                            let serialValue = 0;
                            if (typeof cellValue === 'number') {
                                serialValue = cellValue;
                            } else if (typeof cellValue === 'string') {
                                // Parse decimal numbers like "8.3"
                                const parsedValue = parseFloat(cellValue);
                                if (!isNaN(parsedValue)) {
                                    serialValue = parsedValue;
                                }
                            }
                            
                            if (serialValue > lastSerial) {
                                lastSerial = serialValue;
                            }
                        }
                    }
                    
                    console.log('Found last serial number in OUT sheet:', lastSerial);
                    return lastSerial;
                    
                } catch (error) {
                    console.error('Error getting last serial number:', error);
                    return 0; // Return 0 as fallback
                }
            }

            getConnectionInfo() {
                return {
                    connected: this.isConnected,
                    spreadsheetId: this.spreadsheetId,
                    hasApiKey: !!this.apiKey
                };
            }
        }

        // Enhanced Coil Data Management Application
        let coilData = [];
        let vehicleData = [];
        let outData = [];
        let loadedFileName = '';
        let vesselName = 'coil-data'; // Default vessel name
        let addedCoils = [];
        let vehicleCoilMap = {};
        let vehicleSerialGroupMap = JSON.parse(localStorage.getItem('vehicleSerialGroupMap')) || {}; // Maps vehicle -> group number
        let currentGroupNumber = parseInt(localStorage.getItem('currentGroupNumber')) || 8; // Current group number for serial assignment - starts from 8 as requested
        let html5QrCode;
        let serialCounter = 1;
        let generatedTextData = []; // Store generated text reports for Google Sheets upload
        
        // Function to extract vessel name from filename
        function extractVesselName(filename) {
            if (!filename) return 'coil-data';
            
            // Remove file extension (.xlsx or .xls)
            const nameWithoutExt = filename.replace(/\.(xlsx|xls)$/i, '');
            
            // If the filename is just 'coil-data', return it as is
            if (nameWithoutExt === 'coil-data') {
                return nameWithoutExt;
            }
            
            // Handle vessel names with periods and special characters
            // Examples: "M.V. POAVOSA ACE V.2506W", "M.V. SHIP NAME", etc.
            // Clean up the name by preserving the original vessel name structure
            const cleanName = nameWithoutExt.trim();
            
            // Return the cleaned vessel name
            return cleanName || 'coil-data';
        }
        
        // Function to update vessel name when file changes
        function updateVesselName(filename) {
            vesselName = extractVesselName(filename);
            console.log('Vessel name updated to:', vesselName);
        }

        // Global instances
        window.permissionManager = new PermissionManager();
        window.googleSheetsAPI = new GoogleSheetsAPI();

        // Initialize app when device is ready
        document.addEventListener('deviceready', onDeviceReady, false);

        // Fallback for browser testing
        if (typeof cordova === 'undefined') {
            document.addEventListener('DOMContentLoaded', onDeviceReady);
        }

        async function onDeviceReady() {
            console.log('Device ready - initializing app');
            
            try {
                // Auto-configure Google API key and Web App URL from environment
                // Try to get API key from server-side environment variable
                let apiKeyFromEnv = '';
                try {
                    // For Replit environment, fetch the environment variable from a backend endpoint
                    const response = await fetch('/env/GOOGLE_API_KEY').catch(() => null);
                    if (response && response.ok) {
                        apiKeyFromEnv = await response.text();
                        console.log('Retrieved Google API key from server environment');
                    }
                } catch (error) {
                    console.log('Could not fetch API key from server, using fallback method');
                }
                
                // Fallback: check if key was injected during build
                if (!apiKeyFromEnv) {
                    const injectedKey = '${GOOGLE_API_KEY}'.replace('${GOOGLE_API_KEY}', '');
                    if (injectedKey && injectedKey.length > 10) {
                        apiKeyFromEnv = injectedKey;
                        console.log('Using injected API key from build process');
                    }
                }
                
                const webAppUrlFromEnv = 'https://script.google.com/macros/s/AKfycbx9KYWooFcK_35P9iBpYRW-Ql2jMc2EmxbaI6siyxM1Vkqnpoay-6O-V4K8BX7TFrbt/exec';
                
                if (apiKeyFromEnv && apiKeyFromEnv.length > 10) {
                    console.log('Setting Google API key from environment');
                    const apiKeyInput = document.getElementById('apiKey');
                    if (apiKeyInput) {
                        apiKeyInput.value = apiKeyFromEnv;
                    }
                    
                    // Also set the Google Drive API key for PDF storage
                    window.GOOGLE_API_KEY = apiKeyFromEnv;
                    GOOGLE_DRIVE_CONFIG.API_KEY = apiKeyFromEnv;
                    console.log('Google Drive API key configured from environment');
                    
                    // Initialize Google Drive API now that we have the key
                    try {
                        await googleDriveManager.initialize();
                        console.log('Google Drive API successfully initialized with environment key');
                    } catch (error) {
                        console.log('Google Drive API initialization failed:', error);
                    }
                } else {
                    console.log('No valid API key found in environment - using manual configuration');
                }
                
                // Configure Web App URL from environment or stored value
                let finalWebAppUrl = '';
                if (webAppUrlFromEnv && !webAppUrlFromEnv.includes('${') && webAppUrlFromEnv.length > 10) {
                    console.log('Setting Google Apps Script Web App URL from environment');
                    finalWebAppUrl = webAppUrlFromEnv;
                    const webAppUrlInput = document.getElementById('webAppUrl');
                    if (webAppUrlInput) {
                        webAppUrlInput.value = webAppUrlFromEnv;
                    }
                    // Store it for future use
                    localStorage.setItem('googleSheets_webAppUrl', webAppUrlFromEnv);
                } else {
                    // Load stored Web App URL
                    finalWebAppUrl = localStorage.getItem('googleSheets_webAppUrl') || '';
                    const webAppUrlInput = document.getElementById('webAppUrl');
                    if (webAppUrlInput && finalWebAppUrl) {
                        webAppUrlInput.value = finalWebAppUrl;
                    }
                }
                
                // Auto-connect to Google Sheets if credentials are available
                const spreadsheetInput = document.getElementById('spreadsheetId');
                if (spreadsheetInput) {
                    const spreadsheetId = spreadsheetInput.value.trim();
                    if (spreadsheetId) {
                        window.googleSheetsAPI.setCredentials(spreadsheetId, apiKeyFromEnv || '', finalWebAppUrl);
                        console.log('Auto-configured Google Sheets credentials with API key and Web App URL');
                        if (finalWebAppUrl) {
                            console.log(' Google Apps Script Web App URL configured - direct Google Sheets writing enabled');
                        }
                    }
                }
                
                // Initialize permissions
                if (window.permissionManager) {
                    window.permissionManager.initialize().catch(error => {
                        console.warn('Permission manager initialization failed:', error);
                    });
                }
                
                // Initialize OUT data in memory only (no persistence)
                try {
                    window.outData = [];
                    console.log('Initialized empty OUT data in memory (no persistence)');
                } catch (error) {
                    console.warn('Error initializing OUT data:', error);
                    window.outData = [];
                }
                
                // Load initial coil data 
                await autoLoadFromGoogleSheets();
                
                // Load OUT data for serial counter (redundant but ensures serial counter works)
                await loadOutDataForSerial();
                
                // Set up file input handler - check for available file inputs
                const fileInput = document.getElementById('excelFile') || document.querySelector('input[type="file"]');
                if (fileInput) {
                    fileInput.addEventListener('change', handleFileSelect);
                } else {
                    console.log('No file input element found - file upload functionality disabled');
                }
                
                // Update Google Sheets button status
                updateGoogleSheetsButtonStatus();
                
                console.log('App initialization complete');
                
                // Update shipment summary after initialization with longer delay to ensure all data is loaded
                setTimeout(() => {
                    console.log('Final shipment summary update triggered after initialization');
                    updateShipmentSummary();
                }, 3000);
                
            } catch (error) {
                console.error('App initialization failed:', error);
                showMessage('App initialization failed: ' + error.message, 'error');
            }
        }

        // Auto-load data from Google Sheets on startup
        async function autoLoadFromGoogleSheets() {
            try {
                console.log('Attempting to auto-load data from Google Sheets...');
                
                // Check if credentials are available
                const credentials = window.googleSheetsAPI.getCredentials();
                if (!credentials.spreadsheetId) {
                    console.log('No Google Sheets credentials found - skipping auto-load');
                    return;
                }
                
                showMessage('Loading data from Google Sheets...', 'info');
                const sheetsData = await window.googleSheetsAPI.fetchExcelFile();
                const { mainData, fileName, sheetNames } = sheetsData;
                
                console.log('Available sheets:', sheetNames);
                console.log('Main data loaded:', mainData.length, 'records');
                
                // Use main data as coil data
                coilData = mainData;
                
                // Try to find vehicle data in other sheets
                try {
                    const vehicleSheetName = sheetNames.find(name => 
                        name.toLowerCase().includes('veh') || name.toLowerCase().includes('vehicle')
                    );
                    if (vehicleSheetName) {
                        vehicleData = await window.googleSheetsAPI.loadSheetData(vehicleSheetName);
                        console.log('Loaded vehicle data:', vehicleData.length, 'records');
                    }
                } catch (error) {
                    console.log('No vehicle sheet found or error loading:', error);
                    vehicleData = [];
                }
                
                loadedFileName = `Google Sheets: ${fileName}`;
                
                // Extract vessel name from data instead of filename
                if (mainData.length > 0) {
                    const vesselNameFromData = mainData[0]['Vessel Name'] || mainData[0]['VESSEL NAME'] || mainData[0]['vessel name'] || '';
                    if (vesselNameFromData) {
                        vesselName = vesselNameFromData;
                        console.log('Vessel name updated from data to:', vesselName);
                    } else {
                        updateVesselName(fileName); // Fallback to filename if no vessel name in data
                    }
                } else {
                    updateVesselName(fileName); // Fallback to filename
                }
                
                const fileNameElement = document.getElementById('fileName');
                if (fileNameElement) {
                    fileNameElement.textContent = `Successfully loaded ${coilData.length} coils from Google Sheets`;
                }
                
                showMessage(`Successfully loaded ${coilData.length} coils from Google Sheets`, 'success');
                
            } catch (error) {
                console.log('Google Sheets auto-load failed:', error.message);
                const fileNameElement = document.getElementById('fileName');
                if (fileNameElement) {
                    fileNameElement.textContent = 'Please set Google Sheets credentials or upload Excel file manually.';
                }
                // Don't show error message for missing credentials - this is expected on first load
                if (!error.message.includes('ID is required')) {
                    showMessage('Google Sheets connection failed: ' + error.message, 'error');
                }
            }
        }

        async function loadOutDataForSerial() {
            try {
                // Check if Google Sheets credentials are available
                const credentials = window.googleSheetsAPI.getCredentials();
                if (!credentials.spreadsheetId) {
                    console.log('No Google Sheets credentials - using stored group number or default');
                    return;
                }
                
                const googleSheetsOutData = await window.googleSheetsAPI.loadOutData();
                
                if (googleSheetsOutData.length > 0) {
                    console.log('Found existing OUT data:', googleSheetsOutData.length, 'records');
                    
                    // Find the highest serial number in format "X.Y"
                    let maxGroupNumber = 0;
                    let maxSubNumber = {};
                    
                    googleSheetsOutData.forEach(row => {
                        const serialNo = row['SERIAL NO'] || row['Serial No'] || row['serialNumber'] || '';
                        if (serialNo.includes('.')) {
                            const [groupStr, subStr] = String(serialNo).split('.');
                            const groupNum = parseInt(groupStr);
                            const subNum = parseInt(subStr);
                            
                            if (!isNaN(groupNum) && !isNaN(subNum)) {
                                maxGroupNumber = Math.max(maxGroupNumber, groupNum);
                                if (!maxSubNumber[groupNum] || maxSubNumber[groupNum] < subNum) {
                                    maxSubNumber[groupNum] = subNum;
                                }
                            }
                        }
                    });
                    
                    // Update currentGroupNumber based on existing data
                    if (maxGroupNumber > 0) {
                        // Check if the latest group has space for more entries
                        const latestGroupCount = maxSubNumber[maxGroupNumber] || 0;
                        currentGroupNumber = maxGroupNumber;
                        
                        // Store the updated group number
                        localStorage.setItem('currentGroupNumber', currentGroupNumber);
                        console.log(`Serial numbering will continue from group ${currentGroupNumber}, last sub-number was ${latestGroupCount}`);
                        
                        // Update vehicle-to-group mapping based on existing data
                        googleSheetsOutData.forEach(row => {
                            const vehicleNo = row['VEHICLE NO'] || row['Vehicle No'] || row['vehicleNumber'] || '';
                            const serialNo = row['SERIAL NO'] || row['Serial No'] || row['serialNumber'] || '';
                            
                            if (vehicleNo && serialNo && serialNo.includes('.')) {
                                const groupNum = parseInt(String(serialNo).split('.')[0]);
                                if (!isNaN(groupNum)) {
                                    vehicleSerialGroupMap[vehicleNo] = groupNum;
                                }
                            }
                        });
                        
                        localStorage.setItem('vehicleSerialGroupMap', JSON.stringify(vehicleSerialGroupMap));
                        console.log('Updated vehicle-group mapping from existing OUT data');
                        
                        // Note: Shipment summary will be updated after full initialization
                        
                        // Extract vessel name from OUT data if available
                        const vesselNameFromOutData = googleSheetsOutData[0]['Vessel Name'] || googleSheetsOutData[0]['VESSEL NAME'] || googleSheetsOutData[0]['vessel name'] || '';
                        if (vesselNameFromOutData) {
                            vesselName = vesselNameFromOutData;
                            console.log('Vessel name updated from OUT data to:', vesselName);
                        }
                    } else {
                        currentGroupNumber = parseInt(localStorage.getItem('currentGroupNumber')) || 8;
                        console.log('No valid serial numbers found in OUT data, using stored/default group number:', currentGroupNumber);
                    }
                } else {
                    currentGroupNumber = parseInt(localStorage.getItem('currentGroupNumber')) || 8;
                    console.log('No existing OUT data found, using stored/default group number:', currentGroupNumber);
                }
                
            } catch (error) {
                console.log('Could not load OUT data for serial counter, using stored/default:', error.message);
                currentGroupNumber = parseInt(localStorage.getItem('currentGroupNumber')) || 8;
            }
        }

        function handleFileUpload() {
            const fileInput = document.getElementById('excelFile');
            if (fileInput && fileInput.files[0]) {
                handleFileSelect({ target: fileInput });
            } else {
                showMessage('Please select an Excel file first', 'error');
            }
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    
                    console.log('Manual file load - Available sheets:', workbook.SheetNames);
                    
                    // Load PNR sheet (coil data)
                    if (workbook.SheetNames.includes('PNR')) {
                        const pnrSheet = workbook.Sheets['PNR'];
                        coilData = XLSX.utils.sheet_to_json(pnrSheet);
                        console.log('Loaded PNR data:', coilData.length, 'records');
                    }
                    
                    // Load VEH sheet
                    if (workbook.SheetNames.includes('VEH')) {
                        const vehicleSheet = workbook.Sheets['VEH'];
                        vehicleData = XLSX.utils.sheet_to_json(vehicleSheet);
                        console.log('Loaded VEH data:', vehicleData.length, 'records');
                    }
                    
                    // Load OUT sheet for existing data and serial counter
                    if (workbook.SheetNames.includes('OUT')) {
                        const outSheet = workbook.Sheets['OUT'];
                        outData = XLSX.utils.sheet_to_json(outSheet);
                        
                        if (outData.length > 0) {
                            const maxSerial = Math.max(...outData.map(row => parseInt(row['SERIAL NO']) || 0));
                            serialCounter = maxSerial + 1;
                        } else {
                            // If no existing data, ensure serial counter starts from 1
                            serialCounter = 1;
                        }
                    } else {
                        // If no OUT sheet exists, ensure serial counter starts from 1
                        serialCounter = 1;
                    }
                    
                    loadedFileName = file.name;
                    
                    // Extract vessel name from uploaded data instead of filename
                    if (coilData.length > 0) {
                        const vesselNameFromData = coilData[0]['Vessel Name'] || coilData[0]['VESSEL NAME'] || coilData[0]['vessel name'] || '';
                        if (vesselNameFromData) {
                            vesselName = vesselNameFromData;
                            console.log('Vessel name updated from uploaded data to:', vesselName);
                        } else {
                            updateVesselName(file.name); // Fallback to filename if no vessel name in data
                        }
                    } else {
                        updateVesselName(file.name); // Fallback to filename
                    }
                    
                    document.getElementById('fileName').textContent = `Loaded: ${loadedFileName}`;
                    showMessage('Excel file loaded successfully!', 'success');
                    
                } catch (error) {
                    console.error('Error reading Excel file:', error);
                    showMessage('Error reading Excel file: ' + error.message, 'error');
                }
            };
            reader.readAsArrayBuffer(file);
        }

        function searchCoil() {
            const coilNumber = document.getElementById('coilInput').value.trim().toUpperCase();
            
            if (!coilNumber) {
                return;
            }
            
            if (coilData.length === 0) {
                showCoilModal('No Excel data loaded. Please upload an Excel file first.', null, true);
                return;
            }
            
            const matchKey = Object.keys(coilData[0] || {}).find(key => 
                key.trim().toUpperCase() === 'MILL COIL NO' || 
                key.trim().toUpperCase() === 'COIL NO' ||
                key.trim().toUpperCase().includes('MILL COIL')
            );
            
            if (!matchKey) {
                showCoilModal('Could not find MILL COIL NO column in Excel data.', null, true);
                return;
            }
            
            const coil = coilData.find(row => 
                String(row[matchKey]).trim().toUpperCase() === coilNumber
            );
            
            if (coil) {
                showCoilModal(`Coil Details - ${coilNumber}`, coil, false);
            } else {
                showCoilModal('Coil not found in database.', null, true);
            }
        }

        function showCoilModal(title, coilData, isError) {
            const modal = document.getElementById('coilModal');
            const modalTitle = document.getElementById('coilModalTitle');
            const modalBody = document.getElementById('coilModalBody');
            
            modalTitle.textContent = title;
            
            if (isError) {
                modalBody.innerHTML = `<div class="coil-not-found">${title}</div>`;
            } else if (coilData) {
                let html = '<table class="coil-details-table">';
                Object.entries(coilData).forEach(([key, value]) => {
                    if (value !== null && value !== undefined && value !== '') {
                        html += `<tr><td>${key}</td><td>${value}</td></tr>`;
                    }
                });
                html += '</table>';
                modalBody.innerHTML = html;
            }
            
            // Show the modal with animation
            modal.style.display = 'block';
            modal.style.visibility = 'visible';
            modal.style.opacity = '0';
            
            setTimeout(() => {
                modal.classList.add('show');
                modal.style.opacity = '1';
            }, 10);
        }

        function closeCoilModal() {
            const modal = document.getElementById('coilModal');
            
            modal.classList.remove('show');
            modal.style.opacity = '0';
            
            setTimeout(() => {
                modal.style.display = 'none';
                modal.style.visibility = 'hidden';
            }, 300);
        }

        // Close modal when clicking outside of it
        document.addEventListener('click', function(event) {
            const modal = document.getElementById('coilModal');
            if (event.target === modal) {
                closeCoilModal();
            }
        });

        // Close modal with Escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                const modal = document.getElementById('coilModal');
                if (modal.classList.contains('show')) {
                    closeCoilModal();
                }
            }
        });

        function showSuggestions() {
            const input = document.getElementById('coilInput').value.trim().toUpperCase();
            const suggestions = document.getElementById('suggestions');
            
            if (input.length === 0) {
                suggestions.style.display = 'none';
                return;
            }
            
            const matches = coilData.filter(row => {
                const matchKey = Object.keys(row).find(k => k.trim().toUpperCase() === 'MILL COIL NO');
                return matchKey && String(row[matchKey]).trim().toUpperCase().includes(input);
            }).slice(0, 10);
            
            if (matches.length > 0) {
                suggestions.innerHTML = matches.map(row => {
                    const matchKey = Object.keys(row).find(k => k.trim().toUpperCase() === 'MILL COIL NO');
                    return `<div onclick="selectSuggestion('${row[matchKey]}')">${row[matchKey]}</div>`;
                }).join('');
                suggestions.style.display = 'block';
            } else {
                suggestions.style.display = 'none';
            }
        }

        function selectSuggestion(coilNumber) {
            document.getElementById('coilInput').value = coilNumber;
            document.getElementById('suggestions').style.display = 'none';
            searchCoil();
            toggleClearButton();
        }

        function toggleClearButton() {
            // This function exists for compatibility
        }

        async function startScanner() {
            try {
                // Check camera permission first
                if (window.permissionManager && !window.permissionManager.isCameraPermissionGranted()) {
                    const granted = await window.permissionManager.requestCameraPermission();
                    if (!granted) {
                        showMessage('Camera permission is required for QR code scanning', 'error');
                        return;
                    }
                }
                
                const reader = document.getElementById('reader');
                
                if (html5QrCode && html5QrCode.getState() === Html5QrcodeScannerState.SCANNING) {
                    console.log('Scanner already running');
                    return;
                }
                
                html5QrCode = new Html5Qrcode("reader");
                
                const config = {
                    fps: 10,
                    qrbox: { width: 250, height: 250 },
                    aspectRatio: 1.0
                };
                
                await html5QrCode.start(
                    { facingMode: "environment" },
                    config,
                    (decodedText, decodedResult) => {
                        console.log('QR Code scanned:', decodedText);
                        document.getElementById('coilInput').value = decodedText.trim();
                        searchCoil();
                        closeScanner();
                    },
                    (errorMessage) => {
                        // Ignore scanning errors
                    }
                );
                
                showMessage('QR Scanner started. Double-tap to close.', 'info');
                
            } catch (error) {
                console.error('Error starting QR scanner:', error);
                showMessage('Error starting QR scanner: ' + error.message, 'error');
            }
        }

        async function closeScanner() {
            try {
                if (html5QrCode) {
                    await html5QrCode.stop();
                    html5QrCode = null;
                    document.getElementById('reader').innerHTML = '';
                    showMessage('QR Scanner closed', 'info');
                }
            } catch (error) {
                console.error('Error closing QR scanner:', error);
            }
        }

        function showVehicleSuggestions() {
            const input = document.getElementById('vehicleInput').value.trim().toUpperCase();
            const suggestions = document.getElementById('vehicleSuggestions');
            
            if (input.length === 0) {
                suggestions.style.display = 'none';
                return;
            }
            
            const matches = vehicleData.filter(row => {
                const matchKey = Object.keys(row).find(k => k.trim().toUpperCase() === 'VEHICLE NO');
                return matchKey && String(row[matchKey]).trim().toUpperCase().includes(input);
            }).slice(0, 10);
            
            if (matches.length > 0) {
                suggestions.innerHTML = matches.map(row => {
                    const matchKey = Object.keys(row).find(k => k.trim().toUpperCase() === 'VEHICLE NO');
                    return `<div onclick="selectVehicleSuggestion('${row[matchKey]}')">${row[matchKey]}</div>`;
                }).join('');
                suggestions.style.display = 'block';
            } else {
                suggestions.style.display = 'none';
            }
        }

        function selectVehicleSuggestion(vehicleNumber) {
            document.getElementById('vehicleInput').value = vehicleNumber;
            document.getElementById('vehicleSuggestions').style.display = 'none';
            toggleVehicleClearButton();
        }

        function toggleVehicleClearButton() {
            const input = document.getElementById('vehicleInput').value.trim();
            const clearBtn = document.getElementById('clearVehicleBtn');
            if (clearBtn) {
                clearBtn.style.display = input ? 'block' : 'none';
            }
        }

        function clearVehicleInput() {
            document.getElementById('vehicleInput').value = '';
            document.getElementById('vehicleSuggestions').style.display = 'none';
            toggleVehicleClearButton();
        }

        async function showCoilSerialSuggestions() {
            const vehicleInput = document.getElementById('reportVehicleInput').value.trim().toUpperCase();
            const coilSerialInput = document.getElementById('coilSerialInput').value.trim();
            const suggestions = document.getElementById('coilSerialSuggestions');
            
            // Show suggestions if vehicle is present (allow empty coil serial input)
            if (!vehicleInput) {
                suggestions.style.display = 'none';
                return;
            }
            
            try {
                // Load fresh data from Google Sheets/local storage like the reports do
                let reportData = [];
                
                // Load fresh data from Google Sheets (no localStorage for multi-user app)
                try {
                    console.log('Loading fresh data for coil serial autocomplete...');
                    reportData = await window.googleSheetsAPI.loadOutSheetForReporting();
                    console.log('Fresh Google Sheets data loaded for autocomplete:', reportData.length, 'records');
                    
                    if (reportData.length === 0) {
                        // If no data from Google Sheets, try session data as fallback
                        reportData = window.outData || [];
                        console.log('Using session data as fallback for autocomplete:', reportData.length, 'records');
                    }
                } catch (error) {
                    console.error('Error loading fresh OUT data for autocomplete:', error);
                    // Final fallback to session data only
                    reportData = window.outData || [];
                    console.log('Using session data as final fallback for autocomplete:', reportData.length, 'records');
                }
                
                // Get serial numbers for the selected vehicle from loaded data
                const vehicleSerials = [];
                
                if (reportData && reportData.length > 0) {
                    // Find all records for this vehicle
                    const vehicleRecords = reportData.filter(row => {
                        const vehicleNo = String(row['VEHICLE NO'] || '').trim().toUpperCase();
                        return vehicleNo === vehicleInput;
                    });
                    
                    console.log(`Found ${vehicleRecords.length} records for vehicle ${vehicleInput}`);
                    
                    // Extract base serial numbers (without decimals)
                    const baseSerials = new Set();
                    vehicleRecords.forEach(row => {
                        const serialNo = String(row['SERIAL NO'] || '').trim();
                        if (serialNo && serialNo !== '') {
                            // Extract base number (before decimal point)
                            const baseSerial = serialNo.split('.')[0];
                            if (baseSerial) {
                                baseSerials.add(baseSerial);
                            }
                        }
                    });
                    
                    // Convert Set to Array
                    vehicleSerials.push(...Array.from(baseSerials));
                    
                    console.log('Vehicle serials found:', vehicleSerials);
                    
                    // Sort in descending order (highest serial number first)
                    vehicleSerials.sort((a, b) => {
                        const numA = parseInt(a) || 0;
                        const numB = parseInt(b) || 0;
                        return numB - numA;
                    });
                    
                    console.log('Sorted vehicle serials:', vehicleSerials);
                }
                
                // Filter based on coil serial input if provided
                let filteredSerials = vehicleSerials;
                if (coilSerialInput.length > 0) {
                    filteredSerials = vehicleSerials.filter(serial => 
                        serial.toLowerCase().includes(coilSerialInput.toLowerCase())
                    );
                }
                
                if (filteredSerials.length > 0) {
                    suggestions.innerHTML = filteredSerials.map(serial => 
                        `<div onclick="selectCoilSerialSuggestion('${serial}')">${serial}</div>`
                    ).join('');
                    suggestions.style.display = 'block';
                } else {
                    console.log('No filtered serials to show');
                    suggestions.style.display = 'none';
                }
                
            } catch (error) {
                console.error('Error in showCoilSerialSuggestions:', error);
                suggestions.style.display = 'none';
            }
        }

        function selectCoilSerialSuggestion(serialGroup) {
            document.getElementById('coilSerialInput').value = serialGroup;
            document.getElementById('coilSerialSuggestions').style.display = 'none';
        }

        function addCoilToVehicle() {
            const vehicleInput = document.getElementById('vehicleInput');
            const coilInput = document.getElementById('coilInput');
            
            vehicleInput.disabled = true;
            
            const coil = coilInput.value.trim().toUpperCase();
            const vehicle = vehicleInput.value.trim().toUpperCase();
            
            if (!coil || !vehicle) {
                showMessage('Please enter both coil and vehicle number', 'error');
                vehicleInput.disabled = false;
                return;
            }
            
            // Check if coil is already saved in vehicleCoilMap
            let coilAlreadySaved = false;
            for (const [savedVehicle, savedCoils] of Object.entries(vehicleCoilMap)) {
                if (savedCoils.includes(coil)) {
                    showMessage(` WARNING: Coil ${coil} is already saved for vehicle ${savedVehicle}`, 'error');
                    vehicleInput.disabled = false;
                    return;
                }
            }
            
            // Check if coil is already added in current session
            const coilAlreadyAdded = addedCoils.some(item => item.coilNumber === coil);
            if (coilAlreadyAdded) {
                showMessage(` WARNING: Coil ${coil} is already added to the current list`, 'error');
                vehicleInput.disabled = false;
                return;
            }
            
            addedCoils.push({ coilNumber: coil, vehicleNumber: vehicle });
            updateAddedCoilsDisplay();
            
            coilInput.value = '';
            document.getElementById('result').innerHTML = '';
            document.getElementById('suggestions').style.display = 'none';
            
            showMessage('Coil added to vehicle successfully', 'success');
        }

        function updateAddedCoilsDisplay() {
            const div = document.getElementById('addedCoils');
            if (addedCoils.length === 0) {
                div.innerHTML = '';
                return;
            }
            
            // Calculate total gross weight
            let totalGrossWeight = 0;
            addedCoils.forEach(item => {
                const coilDetails = findCoilDetails(item.coilNumber);
                if (coilDetails) {
                    const grossWeightKey = Object.keys(coilDetails).find(key => 
                        key.trim().toUpperCase() === 'GROSS WT' || 
                        key.trim().toUpperCase() === 'GROSS WEIGHT' ||
                        key.trim().toUpperCase().includes('GROSS')
                    );
                    if (grossWeightKey) {
                        const weight = parseFloat(coilDetails[grossWeightKey]) || 0;
                        totalGrossWeight += weight;
                    }
                }
            });
            
            let html = `<h3>Added Coils: | Total G.WT : ${(totalGrossWeight/1000).toFixed(3)}</h3>`;
            addedCoils.forEach((item, index) => {
                html += `<div style="background: rgba(255,255,255,0.1); padding: 8px; margin: 5px 0; border-radius: 5px; display: flex; justify-content: space-between; align-items: center;">
                  <span>${item.coilNumber}  ${item.vehicleNumber}</span>
                  <button onclick="removeCoil(${index})" style="padding: 2px 4px; font-size: 9px; background: #e74c3c; color: white; border: none; border-radius: 2px; cursor: pointer; min-width: 45px;">Remove</button>
                </div>`;
            });
            div.innerHTML = html;
        }

        function removeCoil(index) {
            addedCoils.splice(index, 1);
            updateAddedCoilsDisplay();
        }

        function updateVehicleCountDisplay() {
            const vehicleCount = Object.keys(vehicleCoilMap).length;
            const totalCoils = Object.values(vehicleCoilMap).reduce((sum, coils) => sum + coils.length, 0);
            
            let countDisplay = document.getElementById('vehicleCountDisplay');
            if (!countDisplay) {
                countDisplay = document.createElement('div');
                countDisplay.id = 'vehicleCountDisplay';
                countDisplay.className = 'vehicle-count';
                
                // Insert after the addedCoils div
                const addedCoilsDiv = document.getElementById('addedCoils');
                if (addedCoilsDiv) {
                    addedCoilsDiv.parentNode.insertBefore(countDisplay, addedCoilsDiv.nextSibling);
                }
            }
            
            countDisplay.innerHTML = `
                <div style="text-align: center; font-size: 16px; margin: 10px 0;">
                    <strong>Shipment Summary:</strong><br>
                    Vehicles Used: ${vehicleCount} | Total Coils: ${totalCoils} | Current Group: ${currentGroupNumber}
                </div>
            `;
        }

        async function saveVehicleCoils() {
            if (!addedCoils.length) {
                showMessage('No coils to save', 'error');
                return;
            }
            
            console.log('Save button clicked - checking generated text data:', generatedTextData.length, 'reports available');
            
            try {
                // Get the last serial number from Google Sheets to determine next group number
                // showMessage('Checking last serial number in OUT sheet...', 'info'); // Removed to reduce messages
                let lastSerial = 0;
                let nextGroupNumber = 8; // Default starting group
                
                try {
                    // Try to get last serial from Google Sheets
                    lastSerial = await window.googleSheetsAPI.getLastSerial('OUT');
                    console.log('Last serial number from Google Sheets:', lastSerial);
                    
                    if (lastSerial > 0) {
                        // Parse the group number from serial format like "8.3" -> next group is 9
                        const lastSerialStr = lastSerial.toString();
                        if (lastSerialStr.includes('.')) {
                            const groupPart = parseInt(lastSerialStr.split('.')[0]);
                            if (!isNaN(groupPart)) {
                                nextGroupNumber = groupPart + 1; // Next group after the last one
                            }
                        } else {
                            // If it's a whole number, increment by 1
                            nextGroupNumber = Math.floor(lastSerial) + 1;
                        }
                    }
                } catch (error) {
                    console.warn('Could not get last serial number from Google Sheets:', error.message);
                    console.log('Using default starting group number:', nextGroupNumber);
                }
                
                console.log(`Next group number will be: ${nextGroupNumber} (based on last serial: ${lastSerial})`);
                // showMessage(`Starting new group: ${nextGroupNumber}`, 'info'); // Removed to reduce messages
                
                // Simple approach: Use the next group number for all coils in this batch
                const groupNumber = nextGroupNumber;
                console.log(`Using group number ${groupNumber} for all coils in this batch`);
                
                // Generate OUT entries for storage
                const now = new Date();
                const currentDate = now.toLocaleDateString('en-GB').replace(/\//g, '-');
                const currentTime = now.toLocaleTimeString('en-US', { hour12: true });
                const outEntries = [];
                
                // showMessage(`Generating vessel-specific serial numbers with group ${groupNumber}...`, 'info'); // Removed to reduce messages
                
                // First, group coils by vessel name to generate separate serial numbers for each vessel
                const coilsByVessel = {};
                
                // Group coils by their vessel names from PNR data
                addedCoils.forEach(({ coilNumber, vehicleNumber }) => {
                    const details = findCoilDetails(coilNumber);
                    let coilSpecificVesselName = vesselName; // Default to global vessel name
                    
                    if (details) {
                        // Look for vessel name in the specific coil's PNR data
                        const vesselNameKey = Object.keys(details).find(key => 
                            key.trim().toUpperCase() === 'VESSEL NAME' ||
                            key.trim().toUpperCase() === 'VESSEL' ||
                            key.trim().toUpperCase().includes('VESSEL')
                        );
                        if (vesselNameKey && details[vesselNameKey]) {
                            coilSpecificVesselName = details[vesselNameKey];
                        }
                    }
                    
                    if (!coilsByVessel[coilSpecificVesselName]) {
                        coilsByVessel[coilSpecificVesselName] = [];
                    }
                    coilsByVessel[coilSpecificVesselName].push({ coilNumber, vehicleNumber });
                });
                
                console.log('Coils grouped by vessel:', Object.keys(coilsByVessel).map(vessel => `${vessel}: ${coilsByVessel[vessel].length} coils`));
                
                // Generate separate serial numbers for each vessel
                const vesselSerialCounters = {};
                
                Object.keys(coilsByVessel).forEach(vesselName => {
                    vesselSerialCounters[vesselName] = 0;
                });
                
                addedCoils.forEach(({ coilNumber, vehicleNumber }) => {
                    const details = findCoilDetails(coilNumber);
                    let coilSpecificVesselName = vesselName; // Default to global vessel name
                    
                    if (details) {
                        // Look for vessel name in the specific coil's PNR data
                        const vesselNameKey = Object.keys(details).find(key => 
                            key.trim().toUpperCase() === 'VESSEL NAME' ||
                            key.trim().toUpperCase() === 'VESSEL' ||
                            key.trim().toUpperCase().includes('VESSEL')
                        );
                        if (vesselNameKey && details[vesselNameKey]) {
                            coilSpecificVesselName = details[vesselNameKey];
                        }
                    }
                    
                    // Increment counter for this specific vessel
                    vesselSerialCounters[coilSpecificVesselName]++;
                    
                    // Create vessel-specific serial number (e.g., V1: 8.1, 8.2; V2: 8.1, 8.2)
                    const serialNumber = `${groupNumber}.${vesselSerialCounters[coilSpecificVesselName]}`;
                    
                    // Add serial number to coil data
                    const coilIndex = addedCoils.findIndex(item => item.coilNumber === coilNumber && item.vehicleNumber === vehicleNumber);
                    if (coilIndex !== -1) {
                        addedCoils[coilIndex].serialNumber = serialNumber;
                    }
                    
                    console.log(`Assigned serial ${serialNumber} to coil ${coilNumber} for vessel ${coilSpecificVesselName}`);
                });
                
                // Now create OUT entries with the assigned serial numbers
                addedCoils.forEach(({ coilNumber, vehicleNumber, serialNumber }) => {
                    // Find transporter for this vehicle
                    let transporter = '';
                    if (vehicleData.length > 0) {
                        const vehicleColumnKey = Object.keys(vehicleData[0]).find(key => 
                            key.trim().toUpperCase().includes('VEHICLE NO')
                        );
                        
                        const transporterColumnKey = Object.keys(vehicleData[0]).find(key => 
                            key.trim().toUpperCase().includes('TRANSPORTER')
                        );
                        
                        if (vehicleColumnKey && transporterColumnKey) {
                            const vehicleRecord = vehicleData.find(row => 
                                String(row[vehicleColumnKey]).trim().toUpperCase() === vehicleNumber
                            );
                            if (vehicleRecord) {
                                transporter = vehicleRecord[transporterColumnKey] || '';
                            }
                        }
                    }
                    
                    // Find coil details to get gross weight and vessel name
                    const details = findCoilDetails(coilNumber);
                    let grossWeight = '';
                    let coilSpecificVesselName = vesselName; // Default to global vessel name
                    
                    if (details) {
                        // Look for gross weight column
                        const grossWeightKey = Object.keys(details).find(key => 
                            key.trim().toUpperCase().includes('GROSS') && 
                            key.trim().toUpperCase().includes('WT')
                        );
                        if (grossWeightKey) {
                            grossWeight = details[grossWeightKey] || '';
                        }
                        
                        // Look for vessel name in the specific coil's PNR data
                        const vesselNameKey = Object.keys(details).find(key => 
                            key.trim().toUpperCase() === 'VESSEL NAME' ||
                            key.trim().toUpperCase() === 'VESSEL' ||
                            key.trim().toUpperCase().includes('VESSEL')
                        );
                        if (vesselNameKey && details[vesselNameKey]) {
                            coilSpecificVesselName = details[vesselNameKey];
                            console.log(`Using coil-specific vessel name for ${coilNumber}: ${coilSpecificVesselName}`);
                        }
                    }
                    
                    // Create entry with consistent column order matching the Google Sheet
                    const outEntry = {
                        'SERIAL NO': serialNumber,
                        'DATE & TIME': `${currentDate} ${currentTime}`,
                        'VEHICLE NO': vehicleNumber,
                        'MILL COIL NO': coilNumber,
                        'TRANSPORTER': transporter || 'MPT',
                        'GROSS WT': grossWeight,
                        'VESSEL NAME': coilSpecificVesselName  // Use coil-specific vessel name from PNR data
                    };
                    outEntries.push(outEntry);
                });
                
                // Now move current coils to saved map (AFTER serial number calculation)
                addedCoils.forEach(({ coilNumber, vehicleNumber }) => {
                    if (!vehicleCoilMap[vehicleNumber]) vehicleCoilMap[vehicleNumber] = [];
                    vehicleCoilMap[vehicleNumber].push(coilNumber);
                });
                
                // Store data locally and save to Google Sheets
                console.log('=== SAVE OPERATION DEBUG ===');
                console.log('OUT entries to process:', outEntries.length);
                console.log('Added coils count:', addedCoils.length);
                console.log('Sample OUT entry:', outEntries[0]);
                
                if (outEntries.length > 0) {
                    try {
                        // Store in local outData array for app functionality
                        if (!outData) outData = [];
                        outData = [...outData, ...outEntries];
                        console.log('Updated local outData array. Total entries:', outData.length);
                        
                        // Store outData locally so reports can access it
                        localStorage.setItem('outData', JSON.stringify(outData));
                        console.log('Saved outData to localStorage for report generation');
                        
                        // Always generate fresh text reports from the new OUT data during save
                        console.log('Generating fresh text reports from current save operation with', outEntries.length, 'OUT entries');
                        // showMessage('Generating text reports...', 'info'); // Removed to reduce messages
                        
                        // Clear any existing text data for this save operation
                        const existingTextCount = generatedTextData.length;
                        if (existingTextCount > 0) {
                            console.log('Clearing', existingTextCount, 'existing text reports to generate fresh ones');
                        }
                        generatedTextData = []; // Clear existing to generate fresh reports
                        
                        await generateTextReportsFromOutEntries(outEntries);
                        console.log('Fresh text reports generated:', generatedTextData.length, 'reports');
                        if (generatedTextData.length > 0) {
                            // showMessage(`Generated ${generatedTextData.length} text reports successfully. Saving directly to Google Sheets...`, 'info'); // Removed to reduce messages
                        } else {
                            console.error('No text reports were generated despite having', outEntries.length, 'OUT entries');
                        }
                        
                        // Save directly to Google Sheets (no local storage)
                        try {
                            const { spreadsheetId, apiKey, webAppUrl } = window.googleSheetsAPI.getCredentials();
                            if (!spreadsheetId) {
                                throw new Error('Google Sheets not configured. Please connect to Google Sheets first.');
                            }
                            
                            if (!webAppUrl || webAppUrl.includes('YOUR_SCRIPT_ID')) {
                                throw new Error('Google Apps Script Web App URL not configured. Please add your Apps Script URL in the Google Sheets Management section.');
                            }
                            
                            // showMessage('Uploading to Google Sheets...', 'info'); // Removed to reduce messages
                            
                            // Get available sheets to find OUT sheet
                            const sheetNames = await window.googleSheetsAPI.getSheetNames();
                            let outSheetName = sheetNames.find(name => 
                                name.toLowerCase().includes('out') || 
                                name.toLowerCase().includes('output')
                            ) || 'OUT';
                            
                            // Upload OUT data to Google Sheets directly
                            console.log(`Uploading ${outEntries.length} OUT entries to Google Sheets (${outSheetName})`);
                            console.log('=== DETAILED OUT ENTRIES DEBUG ===');
                            outEntries.forEach((entry, index) => {
                                console.log(`Entry ${index + 1}:`, {
                                    'SERIAL NO': entry['SERIAL NO'],
                                    'VEHICLE NO': entry['VEHICLE NO'], 
                                    'MILL COIL NO': entry['MILL COIL NO']
                                });
                            });
                            console.log('=== END DEBUG ===');
                            await window.googleSheetsAPI.appendToSheet(outSheetName, outEntries, false);
                            
                            // Primary focus: Save OUT data to Google Sheets
                            showMessage(` Data Saved Successfully!`, 'success');
                            console.log(`Successfully uploaded ${outEntries.length} entries to Google Sheets`);
                            
                            // Keep generated text data available for report viewing
                            console.log(`Keeping ${generatedTextData.length} generated text reports available for viewing`);
                            
                        } catch (sheetsError) {
                            console.error('Google Sheets upload failed:', sheetsError);
                            
                            // Show manual export option as fallback
                            const shouldExport = confirm(`Google Sheets save failed: ${sheetsError.message}\n\nWould you like to download the data as an Excel file instead?`);
                            
                            if (shouldExport) {
                                try {
                                    // Export as Excel file
                                    const wb = XLSX.utils.book_new();
                                    const ws = XLSX.utils.json_to_sheet(outEntries);
                                    XLSX.utils.book_append_sheet(wb, ws, 'OUT Data');
                                    
                                    const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
                                    const filename = `OUT_Data_${timestamp}.xlsx`;
                                    
                                    XLSX.writeFile(wb, filename);
                                    showMessage(` Data exported as ${filename}. Please upload this file to your Google Sheets manually.`, 'success');
                                    console.log(`Exported ${outEntries.length} records to ${filename}`);
                                } catch (exportError) {
                                    console.error('Export failed:', exportError);
                                    showMessage('Export failed: ' + exportError.message, 'error');
                                }
                            } else {
                                showMessage('Data save cancelled. Data remains in local memory until refresh.', 'warning');
                            }
                            
                            // Don't throw error since we handled the fallback
                            return;
                        }
                        
                    } catch (error) {
                        console.error('Failed to save data:', error);
                        showMessage('Warning: Failed to save data - ' + error.message, 'error');
                        return; // Don't proceed if save fails
                    }
                }
                
                // Group number already incremented when assigning to new vehicles
                
                addedCoils = [];
                updateAddedCoilsDisplay();
                
                // Update vehicle count display
                updateVehicleCountDisplay();
                
                // Clear vehicle input after saving
                const vehicleInput = document.getElementById('vehicleInput');
                if (vehicleInput) {
                    vehicleInput.value = '';
                    vehicleInput.disabled = false;
                }
                
                // Hide vehicle suggestions
                document.getElementById('vehicleSuggestions').style.display = 'none';
                
                // Update button states
                const generateBtn = document.getElementById('generateBtn');
                const addBtn = document.getElementById('addBtn');
                const saveBtn = document.getElementById('saveBtn');
                const scanBtn = document.querySelector('button[onclick="startScanner()"]');
                
                if (generateBtn) generateBtn.disabled = false;
                if (addBtn) addBtn.disabled = true;
                if (saveBtn) saveBtn.disabled = true;
                if (scanBtn) scanBtn.disabled = true; // Disable Scan QR button after save
                
                // Hide clear vehicle button
                toggleVehicleClearButton();
                
            } catch (error) {
                console.error('Error saving vehicle coils:', error);
                showMessage('Error saving vehicle coils: ' + error.message, 'error');
            }
        }

        // Enhanced generateTextFile function with proper storage permissions
        // Helper function to generate text reports from fresh OUT entries during save
        async function generateTextReportsFromOutEntries(outEntries) {
            try {
                console.log('=== STARTING TEXT REPORT GENERATION ===');
                console.log('Input OUT entries:', outEntries.length);
                console.log('Sample OUT entry:', outEntries[0]);
                
                const now = new Date();
                const currentDate = now.toLocaleDateString('en-GB').replace(/\//g, '-');
                const currentTime = now.toLocaleTimeString('en-US', { hour12: true });
                
                console.log('Generating text reports from', outEntries.length, 'OUT entries');
                
                // Group OUT entries by vehicle
                const vehicleCoilData = {};
                outEntries.forEach(entry => {
                    const vehicle = entry['VEHICLE NO'];
                    if (vehicle) {
                        if (!vehicleCoilData[vehicle]) {
                            vehicleCoilData[vehicle] = [];
                        }
                        vehicleCoilData[vehicle].push(entry);
                    }
                });
                
                console.log('Grouped by vehicles:', Object.keys(vehicleCoilData));
                
                // Generate text reports for each vehicle with vessel grouping
                for (const [vehicle, vehicleOutData] of Object.entries(vehicleCoilData)) {
                    // Group coils by vessel name within this vehicle
                    const vesselGroups = {};
                    vehicleOutData.forEach(entry => {
                        const vesselName = entry['VESSEL NAME'] || 'N/A';
                        if (!vesselGroups[vesselName]) {
                            vesselGroups[vesselName] = [];
                        }
                        vesselGroups[vesselName].push(entry);
                    });
                    
                    // Calculate totals for the entire vehicle
                    const totalGrossWeight = vehicleOutData.reduce((sum, row) => {
                        return sum + (parseFloat(row['GROSS WT']) || 0);
                    }, 0);
                    
                    // Generate content with vessel sections
                    let content = `Text Report - ${vehicle}\nGenerated on: ${currentDate} ${currentTime}\n\n`;
                    
                    // Add details for each vessel
                    for (const [currentVesselName, vesselCoils] of Object.entries(vesselGroups)) {
                        const transporter = vesselCoils[0]['TRANSPORTER'] || 'N/A';
                        const vesselTotalWeight = vesselCoils.reduce((sum, row) => {
                            return sum + (parseFloat(row['GROSS WT']) || 0);
                        }, 0);
                        
                        content += `Vessel: ${currentVesselName}\nTransporter: ${transporter}\nCoils in this vessel: ${vesselCoils.length}\nVessel Gross Weight: ${vesselTotalWeight.toFixed(2)}\n\nCoil Details:\n`;
                        
                        vesselCoils.forEach(row => {
                            content += `${row['SERIAL NO']} | ${row['DATE & TIME']} | ${row['VEHICLE NO']} | ${row['MILL COIL NO']} | ${row['GROSS WT']}\n`;
                        });
                        content += '\n';
                    }
                    
                    // Add overall summary
                    content += `Overall Summary:\nTotal Coils: ${vehicleOutData.length}\nTotal Gross Weight: ${totalGrossWeight.toFixed(2)}\n`;
                    
                    // Store generated text data for Google Sheets upload
                    const allVesselNames = Object.keys(vesselGroups).join(', ');
                    const textReportEntry = {
                        'Vehicle No': vehicle,
                        'Report Date': currentDate,
                        'Report Time': currentTime,
                        'Vessel Name': allVesselNames,
                        'Transporter': vehicleOutData[0]['TRANSPORTER'] || 'N/A',
                        'Total Coils': vehicleOutData.length,
                        'Total Gross Weight': totalGrossWeight.toFixed(2),
                        'Report Content': content,
                        'Generated During': 'Save Operation'
                    };
                    generatedTextData.push(textReportEntry);
                    console.log(`Generated text report for vehicle: ${vehicle} (${vehicleOutData.length} coils, ${totalGrossWeight.toFixed(2)} total weight, vessels: ${allVesselNames})`);
                }
                
                console.log(`Generated ${generatedTextData.length} text reports from OUT entries`);
                
            } catch (error) {
                console.error('Error generating text reports from OUT entries:', error);
                // Don't throw error, just log it so save can continue
            }
        }

        // Helper function to generate text reports during save without showing modal
        async function generateTextReportsForSave() {
            try {
                const now = new Date();
                const currentDate = now.toLocaleDateString('en-GB').replace(/\//g, '-');
                const currentTime = now.toLocaleTimeString('en-US', { hour12: true });
                
                // Enhanced data loading - comprehensive approach for text reports
                let allOutData = [];
                
                try {
                    console.log('Loading comprehensive text report data from all sources...');
                    
                    // Load fresh data from Google Sheets
                    let freshData = [];
                    try {
                        freshData = await window.googleSheetsAPI.loadOutData();
                        console.log('Fresh Google Sheets data loaded for text reports:', freshData.length, 'records');
                    } catch (sheetsError) {
                        console.warn('Google Sheets loading failed for text reports:', sheetsError);
                    }
                    
                    // Load local storage data
                    const localData = JSON.parse(localStorage.getItem('outData') || '[]');
                    console.log('Local storage data loaded for text reports:', localData.length, 'records');
                    
                    // Load current session data
                    const sessionData = outData || [];
                    console.log('Session data available for text reports:', sessionData.length, 'records');
                    
                    // Combine all data sources and deduplicate
                    const allDataSources = [...freshData, ...localData, ...sessionData];
                    const uniqueData = [];
                    const seenKeys = new Set();
                    
                    allDataSources.forEach(record => {
                        const uniqueKey = `${record['SERIAL NO']}-${record['MILL COIL NO']}-${record['VEHICLE NO']}`;
                        if (!seenKeys.has(uniqueKey)) {
                            seenKeys.add(uniqueKey);
                            uniqueData.push(record);
                        }
                    });
                    
                    allOutData = uniqueData;
                    console.log('Combined unique data total for text reports:', allOutData.length, 'records');
                    
                } catch (error) {
                    console.error('Error loading comprehensive text report data:', error);
                    // Final fallback to any available data
                    allOutData = outData || JSON.parse(localStorage.getItem('outData') || '[]');
                    console.log('Using final fallback data for text reports, length:', allOutData.length);
                }
                
                if (allOutData.length === 0) {
                    console.log('No OUT data found to generate text report during save - this is expected if no coils have been processed yet');
                    return;
                }
                
                // Group OUT data by vehicle
                const vehicleCoilData = {};
                allOutData.forEach(entry => {
                    const vehicle = entry['VEHICLE NO'];
                    if (vehicle) {
                        if (!vehicleCoilData[vehicle]) {
                            vehicleCoilData[vehicle] = [];
                        }
                        vehicleCoilData[vehicle].push(entry);
                    }
                });
                
                // Generate text reports for each vehicle with vessel grouping (without showing modal)
                for (const [vehicle, vehicleOutData] of Object.entries(vehicleCoilData)) {
                    // Group coils by vessel name within this vehicle
                    const vesselGroups = {};
                    vehicleOutData.forEach(entry => {
                        const vesselName = entry['VESSEL NAME'] || 'N/A';
                        if (!vesselGroups[vesselName]) {
                            vesselGroups[vesselName] = [];
                        }
                        vesselGroups[vesselName].push(entry);
                    });
                    
                    // Calculate totals for the entire vehicle
                    const totalGrossWeight = vehicleOutData.reduce((sum, row) => {
                        return sum + (parseFloat(row['GROSS WT']) || 0);
                    }, 0);
                    
                    // Generate simplified content for storage with vessel sections
                    let content = `Text Report - ${vehicle}\nGenerated on: ${currentDate} ${currentTime}\n\n`;
                    
                    // Add details for each vessel
                    for (const [currentVesselName, vesselCoils] of Object.entries(vesselGroups)) {
                        const transporter = vesselCoils[0]['TRANSPORTER'] || 'N/A';
                        const vesselTotalWeight = vesselCoils.reduce((sum, row) => {
                            return sum + (parseFloat(row['GROSS WT']) || 0);
                        }, 0);
                        
                        content += `Vessel: ${currentVesselName}\nTransporter: ${transporter}\nCoils in this vessel: ${vesselCoils.length}\nVessel Gross Weight: ${vesselTotalWeight.toFixed(2)}\n\nCoil Details:\n`;
                        
                        vesselCoils.forEach(row => {
                            content += `${row['SERIAL NO']} | ${row['DATE & TIME']} | ${row['VEHICLE NO']} | ${row['MILL COIL NO']} | ${row['GROSS WT']}\n`;
                        });
                        content += '\n';
                    }
                    
                    // Add overall summary
                    content += `Overall Summary:\nTotal Coils: ${vehicleOutData.length}\nTotal Gross Weight: ${totalGrossWeight.toFixed(2)}\n`;
                    
                    // Store generated text data for Google Sheets upload
                    const allVesselNames = Object.keys(vesselGroups).join(', ');
                    const textReportEntry = {
                        'Vehicle No': vehicle,
                        'Report Date': currentDate,
                        'Report Time': currentTime,
                        'Vessel Name': allVesselNames,
                        'Transporter': vehicleOutData[0]['TRANSPORTER'] || 'N/A',
                        'Total Coils': vehicleOutData.length,
                        'Total Gross Weight': totalGrossWeight.toFixed(2),
                        'Report Content': content,
                        'Generated During': 'Save Operation'
                    };
                    generatedTextData.push(textReportEntry);
                }
                
                console.log(`Generated ${generatedTextData.length} text reports during save operation`);
                
            } catch (error) {
                console.error('Error generating text reports during save:', error);
                // Don't throw error, just log it so save can continue
            }
        }

        async function generateTextFile() {
            try {
                // Request storage permission first
                if (window.permissionManager && !window.permissionManager.areStoragePermissionsGranted()) {
                    const granted = await window.permissionManager.requestStoragePermission();
                    if (!granted) {
                        showMessage('Storage permission is required to save files', 'error');
                        return;
                    }
                }
                
                const vehicleInput = document.getElementById('vehicleInput');
                if (vehicleInput) {
                    vehicleInput.disabled = false;
                }
                
                const now = new Date();
                const currentDate = now.toLocaleDateString('en-GB').replace(/\//g, '-');
                const currentTime = now.toLocaleTimeString('en-US', { hour12: true });
                
                // Always use OUT data to generate text report
                let allOutData = outData || [];
                
                // If local outData is empty, try to get from Google Sheets
                if (allOutData.length === 0) {
                    try {
                        allOutData = await window.googleSheetsAPI.loadOutData();
                    } catch (error) {
                        console.error('Error loading Google Sheets OUT data:', error);
                        showMessage('Error loading OUT data: ' + error.message, 'error');
                        return;
                    }
                }
                
                if (allOutData.length === 0) {
                    showMessage('No OUT data found to generate text report', 'error');
                    return;
                }
                
                // Group OUT data by vehicle first, then by vessel name within each vehicle
                const vehicleCoilData = {};
                allOutData.forEach(entry => {
                    const vehicle = entry['VEHICLE NO'];
                    if (vehicle) {
                        if (!vehicleCoilData[vehicle]) {
                            vehicleCoilData[vehicle] = [];
                        }
                        vehicleCoilData[vehicle].push(entry);
                    }
                });
                
                // Generate separate file for each vehicle with vessel grouping
                for (const [vehicle, vehicleOutData] of Object.entries(vehicleCoilData)) {
                    // Group coils by vessel name within this vehicle
                    const vesselGroups = {};
                    vehicleOutData.forEach(entry => {
                        const vesselName = entry['VESSEL NAME'] || 'N/A';
                        if (!vesselGroups[vesselName]) {
                            vesselGroups[vesselName] = [];
                        }
                        vesselGroups[vesselName].push(entry);
                    });
                    
                    // Generate HTML content with separate sections for each vessel
                    let content = `<div style="font-family: Arial, sans-serif; padding: 10px;">
                        <h3 style="text-align: center; margin-bottom: 5px;">A.S.Shipping Agencies Pvt Ltd,</h3>
                        <h4 style="text-align: center; margin-top: 0;">(Greenways Group)</h4>
                        <h3 style="text-align: center; color: #2c3e50;">Text Report - ${vehicle}</h3>
                        <p style="text-align: center; margin: 5px 0;">Generated on: ${currentDate} ${currentTime}</p>`;
                    
                    // Create sections for each vessel
                    const vesselNames = Object.keys(vesselGroups);
                    let overallSequenceNo = 1;
                    let totalVehicleWeight = 0;
                    let totalVehicleCoils = 0;
                    
                    for (const [currentVesselName, vesselCoils] of Object.entries(vesselGroups)) {
                        const transporter = vesselCoils[0]['TRANSPORTER'] || 'N/A';
                        const vesselTotalWeight = vesselCoils.reduce((sum, row) => {
                            return sum + (parseFloat(row['GROSS WT']) || 0);
                        }, 0);
                        
                        totalVehicleWeight += vesselTotalWeight;
                        totalVehicleCoils += vesselCoils.length;
                        
                        // Add vessel section header
                        content += `
                        <h4 style="text-align: center; margin-top: 20px; color: #2c3e50;">Vessel Name : ${currentVesselName}</h4>
                        
                        <table style="width: 100%; border-collapse: collapse; margin-top: 20px; font-size: 14px;">
                            <thead>
                                <tr style="background-color: #3498db; color: white;">
                                    <th style="border: 1px solid #ddd; padding: 8px; text-align: center; width: 10%;">Serial No</th>
                                    <th style="border: 1px solid #ddd; padding: 8px; text-align: center; width: 20%;">Date & Time</th>
                                    <th style="border: 1px solid #ddd; padding: 8px; text-align: center; width: 15%;">Transporter</th>
                                    <th style="border: 1px solid #ddd; padding: 8px; text-align: center; width: 15%;">Vehicle No</th>
                                    <th style="border: 1px solid #ddd; padding: 8px; text-align: center; width: 25%;">Coil No</th>
                                    <th style="border: 1px solid #ddd; padding: 8px; text-align: center; width: 15%;">Gross WT</th>
                                </tr>
                            </thead>
                            <tbody>`;
                        
                        // Add data rows for this vessel
                        vesselCoils.forEach((row, index) => {
                            const bgColor = index % 2 === 0 ? '#f9f9f9' : '#ffffff';
                            content += `<tr style="background-color: ${bgColor};">
                                <td style="border: 1px solid #ddd; padding: 6px; text-align: center;">${overallSequenceNo}</td>
                                <td style="border: 1px solid #ddd; padding: 6px; text-align: center;">${row['DATE & TIME'] || ''}</td>
                                <td style="border: 1px solid #ddd; padding: 6px; text-align: center;">${row['TRANSPORTER'] || ''}</td>
                                <td style="border: 1px solid #ddd; padding: 6px; text-align: center;">${row['VEHICLE NO'] || ''}</td>
                                <td style="border: 1px solid #ddd; padding: 6px; text-align: center;">${row['MILL COIL NO'] || ''}</td>
                                <td style="border: 1px solid #ddd; padding: 6px; text-align: right;">${row['GROSS WT'] || ''}</td>
                            </tr>`;
                            overallSequenceNo++;
                        });
                        
                        // Add vessel summary
                        content += `</tbody>
                                <tfoot>
                                    <tr style="background-color: #2c3e50; color: white; font-weight: bold;">
                                        <td colspan="4" style="border: 1px solid #ddd; padding: 8px; text-align: center;">SUMMARY</td>
                                        <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">Total: ${vesselCoils.length}</td>
                                        <td style="border: 1px solid #ddd; padding: 8px; text-align: right;">${vesselTotalWeight.toFixed(2)}</td>
                                    </tr>
                                </tfoot>
                            </table>`;
                    }
                    
                    // Add overall summary
                    content += `
                        <div style="margin-top: 20px; padding: 10px; background-color: #ecf0f1; border-radius: 5px;">
                            <h4 style="margin: 0 0 10px 0;">Summary:</h4>
                            <p style="margin: 5px 0;"><strong>Total Records:</strong> ${totalVehicleCoils}</p>
                            <p style="margin: 5px 0;"><strong>Total Coils:</strong> ${totalVehicleCoils}</p>
                            <p style="margin: 5px 0;"><strong>Total Gross Weight:</strong> ${totalVehicleWeight.toFixed(2)}</p>
                        </div>
                    </div>`;
                    
                    // Always show in modal for better display of HTML table content
                    showReportInModal(`Text Report - ${vehicle}`, content);
                    
                    // Store generated text data for Google Sheets upload  
                    const allVesselNames = Object.keys(vesselGroups).join(', ');
                    const textReportEntry = {
                        'Vehicle No': vehicle,
                        'Report Date': currentDate,
                        'Report Time': currentTime,
                        'Vessel Name': allVesselNames, // Include all vessel names for this vehicle
                        'Transporter': vehicleOutData[0]['TRANSPORTER'] || 'N/A',
                        'Total Coils': totalVehicleCoils,
                        'Total Gross Weight': totalVehicleWeight.toFixed(2),
                        'Report Content': content.replace(/<[^>]*>/g, ''), // Strip HTML tags for plain text
                        'HTML Content': content // Keep HTML version for formatted display
                    };
                    generatedTextData.push(textReportEntry);
                }
                
                // Note: Google Sheets storage is now handled by the Save Button
                
                // Reset for next operation
                vehicleCoilMap = {};
                const generateBtn = document.getElementById('generateBtn');
                const addBtn = document.getElementById('addBtn');
                const saveBtn = document.getElementById('saveBtn');
                const scanBtn = document.querySelector('button[onclick="startScanner()"]');
                
                if (generateBtn) generateBtn.disabled = true;
                if (addBtn) addBtn.disabled = false;
                if (saveBtn) saveBtn.disabled = false;
                if (scanBtn) scanBtn.disabled = false; // Re-enable Scan QR button after generate text
                
                console.log(`Generated ${generatedTextData.length} text reports ready for upload`);
                showMessage('Text reports generated successfully. Click Save to upload to Google Sheets.', 'success');
                
            } catch (error) {
                console.error('Error generating text file:', error);
                showMessage('Error generating text file: ' + error.message, 'error');
            }
        }

        async function saveTextFile(content, fileName) {
            try {
                // Test if we can create download links (this fails in many APK environments)
                const testBlob = new Blob(['test'], { type: 'text/plain' });
                const testUrl = URL.createObjectURL(testBlob);
                const testLink = document.createElement('a');
                
                // If download attribute is not supported or URL creation fails, we're likely in APK
                if (!testLink.download || testUrl.startsWith('blob:null')) {
                    URL.revokeObjectURL(testUrl);
                    throw new Error('Download not supported in this environment');
                }
                
                URL.revokeObjectURL(testUrl);
                
                // Create blob and download
                const blob = new Blob([content], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                console.log(`Text file ${fileName} saved successfully`);
            } catch (error) {
                console.error('Error saving text file:', error);
                throw error;
            }
        }

        function findCoilDetails(coilNumber) {
            if (coilData.length === 0) return null;
            
            const matchKey = Object.keys(coilData[0]).find(key => 
                key.trim().toUpperCase() === 'MILL COIL NO' || 
                key.trim().toUpperCase() === 'COIL NO' ||
                key.trim().toUpperCase().includes('MILL COIL')
            );
            
            if (!matchKey) return null;
            
            return coilData.find(row => 
                String(row[matchKey]).trim().toUpperCase() === coilNumber.trim().toUpperCase()
            );
        }

        function showReportVehicleSuggestions() {
            const input = document.getElementById('reportVehicleInput').value.trim().toUpperCase();
            const suggestions = document.getElementById('reportVehicleSuggestions');
            
            if (input.length === 0) {
                suggestions.style.display = 'none';
                return;
            }
            
            const matches = vehicleData.filter(row => {
                const matchKey = Object.keys(row).find(k => k.trim().toUpperCase() === 'VEHICLE NO');
                return matchKey && String(row[matchKey]).trim().toUpperCase().includes(input);
            }).slice(0, 10);
            
            if (matches.length > 0) {
                suggestions.innerHTML = matches.map(row => {
                    const matchKey = Object.keys(row).find(k => k.trim().toUpperCase() === 'VEHICLE NO');
                    return `<div onclick="selectReportVehicleSuggestion('${row[matchKey]}')">${row[matchKey]}</div>`;
                }).join('');
                suggestions.style.display = 'block';
            } else {
                suggestions.style.display = 'none';
            }
        }

        function selectReportVehicleSuggestion(vehicleNumber) {
            document.getElementById('reportVehicleInput').value = vehicleNumber;
            document.getElementById('reportVehicleSuggestions').style.display = 'none';
            toggleReportVehicleClearButton();
        }

        function toggleReportVehicleClearButton() {
            const input = document.getElementById('reportVehicleInput').value.trim();
            const clearBtn = document.getElementById('clearReportVehicleBtn');
            if (clearBtn) {
                clearBtn.style.display = input ? 'block' : 'none';
            }
        }

        function clearReportVehicleInput() {
            document.getElementById('reportVehicleInput').value = '';
            document.getElementById('coilSerialInput').value = '';
            document.getElementById('reportVehicleSuggestions').style.display = 'none';
            document.getElementById('coilSerialSuggestions').style.display = 'none';
            toggleReportVehicleClearButton();
        }

        // Calculate and update shipment summary statistics
        async function updateShipmentSummary() {
            try {
                // Get fresh data from all sources
                let outData = [];
                let pnrData = coilData; // Use the global coilData variable
                
                // Always load fresh data directly from Google Sheets for consistent results
                try {
                    console.log('Loading fresh OUT data directly from Google Sheets for shipment summary...');
                    // Use loadOutSheetForReporting to get the most current data
                    outData = await window.googleSheetsAPI.loadOutSheetForReporting();
                    console.log('Successfully loaded fresh OUT data from Google Sheets:', outData.length, 'records');
                } catch (error) {
                    console.error('Error loading fresh OUT data from Google Sheets:', error);
                    // Fallback to global window.outData if available
                    if (window.outData && window.outData.length > 0) {
                        outData = window.outData;
                        console.log('Using cached OUT data as fallback:', outData.length, 'records');
                    } else {
                        console.log('No OUT data available for shipment summary');
                        // For sessions without data, show zeros instead of returning
                        outData = [];
                    }
                }
                
                // Vehicle Trips: Last (highest) serial number group from OUT sheet
                const serialNumbers = outData.map(row => {
                    const serialNo = row['SERIAL NO'] || row['Serial No'] || row['serialNumber'] || '';
                    return String(serialNo);
                }).filter(serial => serial && serial.includes('.'));
                
                // Find the highest group number (the number before the dot)
                let maxSerialGroup = 0;
                serialNumbers.forEach(serial => {
                    const groupNum = parseInt(String(serial).split('.')[0]);
                    if (!isNaN(groupNum) && groupNum > maxSerialGroup) {
                        maxSerialGroup = groupNum;
                    }
                });
                
                const totalVehicleTrips = maxSerialGroup;
                
                // Also get vehicle info for reference
                const vehicleNumbers = outData.map(row => {
                    const vehicleValue = row['VEHICLE NO'] || row['VEHICLE'] || row['VEH NO'] || row['Vehicle No'] || row['vehicle no'] || '';
                    return String(vehicleValue).trim().toUpperCase();
                }).filter(v => v && v !== '' && v !== 'UNDEFINED' && v !== 'NULL');
                const uniqueVehicleSet = new Set(vehicleNumbers);
                const uniqueVehicles = uniqueVehicleSet.size;
                
                // Loaded Coils: Count of coil records in OUT sheet
                const totalCoils = outData.length;
                
                // Balance Coils: Count of PNR records - Count of OUT records
                const totalPnrCoils = pnrData ? pnrData.length : 0;
                const balanceCoils = totalPnrCoils - totalCoils;
                
                // Used Transporter: Unique transporters in OUT sheet
                const transporters = outData.map(row => {
                    const transporter = row['TRANSPORTER'] || row['Transporter'] || row['transporter'] || '';
                    return String(transporter).trim();
                }).filter(t => t && t !== '' && t !== 'UNDEFINED' && t !== 'NULL');
                
                const uniqueTransporters = new Set(transporters).size;
                
                // Debug logging for shipment summary
                console.log('Shipment summary calculation debug:', {
                    outDataLength: outData.length,
                    pnrDataLength: totalPnrCoils,
                    serialNumbers: serialNumbers,
                    maxSerialGroup: maxSerialGroup,
                    totalVehicleTrips: totalVehicleTrips,
                    totalCoils: totalCoils,
                    balanceCoils: balanceCoils,
                    transporters: transporters,
                    uniqueTransporters: uniqueTransporters
                });
                
                // Update UI with force refresh
                const totalVehiclesElement = document.getElementById('totalVehicles');
                const totalCoilsElement = document.getElementById('totalCoils');
                const balanceCoilsElement = document.getElementById('balanceCoils');
                const usedTransporterElement = document.getElementById('usedTransporter');
                const summaryElement = document.getElementById('shipmentSummary');
                
                if (totalVehiclesElement) {
                    // Force complete refresh of the element
                    totalVehiclesElement.innerHTML = '';
                    totalVehiclesElement.textContent = `Vehicle Trips: ${totalVehicleTrips}`;
                    totalVehiclesElement.style.color = '#fff';
                    totalVehiclesElement.style.fontWeight = 'bold';
                    console.log('Updated totalVehicles element:', totalVehiclesElement.textContent);
                    console.log('Element innerHTML:', totalVehiclesElement.innerHTML);
                    console.log('Element outerHTML:', totalVehiclesElement.outerHTML);
                }
                if (totalCoilsElement) {
                    totalCoilsElement.textContent = `Loaded Coils: ${totalCoils}`;
                }
                if (balanceCoilsElement) {
                    balanceCoilsElement.textContent = `Balance Coils: ${balanceCoils}`;
                }
                if (usedTransporterElement) {
                    usedTransporterElement.textContent = `Used Transporter: ${uniqueTransporters}`;
                }
                
                // Show the summary section and force reflow
                if (summaryElement) {
                    summaryElement.style.display = 'block';
                    summaryElement.style.visibility = 'visible';
                    // Force a reflow
                    summaryElement.offsetHeight;
                    console.log('Summary element is now visible:', summaryElement.style.display);
                }
                
                // Check for duplicate elements and force page refresh
                const allTotalVehicleElements = document.querySelectorAll('#totalVehicles');
                console.log('Found', allTotalVehicleElements.length, 'elements with ID totalVehicles');
                allTotalVehicleElements.forEach((element, index) => {
                    console.log(`Element ${index}:`, element.textContent);
                    element.textContent = `Vehicle Trips: ${totalVehicleTrips}`;
                    element.style.color = '#fff';
                    element.style.fontWeight = 'bold';
                });
                
                // Force DOM update
                document.body.offsetHeight;
                
                console.log('Shipment summary updated:', {
                    totalVehicleTrips,
                    uniqueVehicles,
                    totalCoils,
                    totalPnrCoils,
                    balanceCoils,
                    uniqueTransporters
                });
                
            } catch (error) {
                console.error('Error updating shipment summary:', error);
            }
        }

        // Enhanced APK Detection Function
        function isRunningInAPK() {
            // Multiple detection methods for different APK builders
            return (
                // Cordova/PhoneGap detection
                typeof cordova !== 'undefined' ||
                typeof window.cordova !== 'undefined' ||
                // WebView detection
                typeof window.AndroidInterface !== 'undefined' ||
                typeof window.webkit !== 'undefined' ||
                // User agent detection for WebView
                navigator.userAgent.includes('wv') ||
                navigator.userAgent.includes('Android') && navigator.userAgent.includes('Version/') ||
                // App protocol detection
                window.location.protocol === 'file:' ||
                // Origin detection for APK
                window.location.origin === 'null' ||
                window.location.hostname === '' ||
                // Additional WebView indicators
                window.navigator.standalone ||
                window.matchMedia('(display-mode: standalone)').matches ||
                // Check if download attribute doesn't work (APK limitation)
                !document.createElement('a').download === undefined
            );
        }

        // APK-Compatible Report Functions - ENHANCED APK DETECTION  
        async function generateAllOutDataReport(event) {
            try {
                // Prevent any default form submission or page refresh
                if (event) {
                    event.preventDefault();
                    event.stopPropagation();
                }
                
                showMessage('Generating all OUT data report...', 'info');
                
                // Force data reload to ensure we have the latest data
                let reportData = [];
                
                // Load fresh data directly from Google Sheets (no localStorage for multi-user app)
                try {
                    console.log('Loading fresh OUT data directly from Google Sheets...');
                    
                    // Load data directly from Google Sheets using the existing API
                    reportData = await window.googleSheetsAPI.loadOutSheetForReporting();
                    console.log('Fresh Google Sheets data loaded:', reportData.length, 'records');
                    
                    if (reportData.length === 0) {
                        // If no data from Google Sheets, try session data as fallback
                        reportData = window.outData || [];
                        console.log('Using session data as fallback:', reportData.length, 'records');
                    }
                    
                } catch (error) {
                    console.error('Error loading fresh OUT data from Google Sheets:', error);
                    // Final fallback to session data only
                    reportData = window.outData || [];
                    console.log('Using session data as final fallback:', reportData.length, 'records');
                }
                
                console.log('Final reportData for All OUT Report:', reportData.length, 'records');
                console.log('Sample data:', reportData.slice(0, 3));
                
                if (reportData.length === 0) {
                    showMessage(' WARNING: No OUT data found to generate report', 'error');
                    return;
                }
                
                // Group coils by vessel name for separate sections
                const vesselGroups = {};
                reportData.forEach(entry => {
                    const vesselName = entry['VESSEL NAME'] || 'N/A';
                    if (!vesselGroups[vesselName]) {
                        vesselGroups[vesselName] = [];
                    }
                    vesselGroups[vesselName].push(entry);
                });
                
                // Generate Excel-like HTML table format report with vessel grouping
                const currentDate = new Date().toLocaleDateString('en-GB').replace(/\//g, '-');
                const currentTime = new Date().toLocaleTimeString('en-US', { hour12: true });
                
                let content = `<div style="font-family: Arial, sans-serif; padding: 10px;">
                    <h3 style="text-align: center; margin-bottom: 5px;">A.S.Shipping Agencies Pvt Ltd,</h3>
                    <h4 style="text-align: center; margin-top: 0;">(Greenways Group)</h4>
                    <h3 style="text-align: center; color: #2c3e50;">ALL OUT DATA REPORT</h3>
                    <p style="text-align: center; margin: 5px 0;">Generated on: ${currentDate} ${currentTime}</p>`;
                
                // Create sections for each vessel
                let totalAllWeight = 0;
                let totalAllCoils = 0;
                
                for (const [currentVesselName, vesselCoils] of Object.entries(vesselGroups)) {
                    const vesselTotalWeight = vesselCoils.reduce((sum, row) => {
                        return sum + (parseFloat(row['GROSS WT']) || 0);
                    }, 0);
                    
                    totalAllWeight += vesselTotalWeight;
                    totalAllCoils += vesselCoils.length;
                    
                    // Add vessel section header
                    content += `
                    <h4 style="text-align: center; margin-top: 20px; color: #2c3e50;">Vessel Name : ${currentVesselName}</h4>
                    
                    <table style="width: 100%; border-collapse: collapse; margin-top: 20px; font-size: 14px;">
                        <thead>
                            <tr style="background-color: #3498db; color: white;">
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: center; width: 10%;">Serial No</th>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: center; width: 20%;">Date & Time</th>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: center; width: 15%;">Transporter</th>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: center; width: 15%;">Vehicle No</th>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: center; width: 25%;">Coil No</th>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: center; width: 15%;">Gross WT</th>
                            </tr>
                        </thead>
                        <tbody>`;
                    
                    // Add data rows for this vessel - serial starts from 1 for each vessel
                    vesselCoils.forEach((row, index) => {
                        const bgColor = index % 2 === 0 ? '#f9f9f9' : '#ffffff';
                        const vesselSerialNo = index + 1; // Start from 1 for each vessel
                        content += `<tr style="background-color: ${bgColor};">
                            <td style="border: 1px solid #ddd; padding: 6px; text-align: center;">${vesselSerialNo}</td>
                            <td style="border: 1px solid #ddd; padding: 6px; text-align: center;">${row['DATE & TIME'] || ''}</td>
                            <td style="border: 1px solid #ddd; padding: 6px; text-align: center;">${row['TRANSPORTER'] || ''}</td>
                            <td style="border: 1px solid #ddd; padding: 6px; text-align: center;">${row['VEHICLE NO'] || ''}</td>
                            <td style="border: 1px solid #ddd; padding: 6px; text-align: center;">${row['MILL COIL NO'] || ''}</td>
                            <td style="border: 1px solid #ddd; padding: 6px; text-align: right;">${row['GROSS WT'] || ''}</td>
                        </tr>`;
                    });
                    
                    // Add vessel summary
                    content += `</tbody>
                            <tfoot>
                                <tr style="background-color: #2c3e50; color: white; font-weight: bold;">
                                    <td colspan="4" style="border: 1px solid #ddd; padding: 8px; text-align: center;">SUMMARY</td>
                                    <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">Total: ${vesselCoils.length}</td>
                                    <td style="border: 1px solid #ddd; padding: 8px; text-align: right;">${vesselTotalWeight.toFixed(2)}</td>
                                </tr>
                            </tfoot>
                        </table>`;
                }
                
                content += `</div>`;
                
                console.log('Final report content length:', content.length);
                console.log('Report data used:', reportData.length, 'records');
                
                // Store report data for PDF generation
                sessionStorage.setItem('currentReportData', JSON.stringify(reportData));
                
                // Always show in modal for better display of HTML table content
                showReportInModal('All OUT Data Report', content);
                
                showMessage(`All OUT data report generated successfully - ${reportData.length} records`, 'success');
                
            } catch (error) {
                console.error('Error generating all OUT data report:', error);
                showMessage('Error generating report: ' + error.message, 'error');
            }
        }

        async function generateVehicleOutReport() {
            try {
                const vehicleNumber = document.getElementById('reportVehicleInput').value.trim().toUpperCase();
                const coilSerial = document.getElementById('coilSerialInput').value.trim();
                
                if (!vehicleNumber) {
                    showMessage('Please enter a vehicle number', 'error');
                    return;
                }
                
                showMessage('Generating vehicle report...', 'info');
                
                // Load fresh data directly from Google Sheets (no localStorage for multi-user app)
                let allOutData = [];
                
                try {
                    console.log('Loading fresh OUT data directly from Google Sheets for vehicle report...');
                    
                    // Load data directly from Google Sheets using the existing API
                    allOutData = await window.googleSheetsAPI.loadOutSheetForReporting();
                    console.log('Fresh Google Sheets data loaded for vehicle report:', allOutData.length, 'records');
                    
                    if (allOutData.length === 0) {
                        // If no data from Google Sheets, try session data as fallback
                        allOutData = window.outData || [];
                        console.log('Using session data as fallback for vehicle report:', allOutData.length, 'records');
                    }
                    
                } catch (error) {
                    console.error('Error loading fresh OUT data from Google Sheets for vehicle report:', error);
                    // Final fallback to session data only
                    allOutData = window.outData || [];
                    console.log('Using session data as final fallback for vehicle report:', allOutData.length, 'records');
                }
                
                let vehicleOutData = allOutData.filter(row => 
                    String(row['VEHICLE NO']).trim().toUpperCase() === vehicleNumber
                );
                
                // Filter by coil serial number if specified
                if (coilSerial) {
                    vehicleOutData = vehicleOutData.filter(row => {
                        const serialNo = String(row['SERIAL NO'] || '').trim();
                        // Match exact serial number or partial match
                        return serialNo === coilSerial || serialNo.includes(coilSerial);
                    });
                    
                    if (vehicleOutData.length === 0) {
                        showMessage(` WARNING: No coils found with serial number ${coilSerial} for vehicle ${vehicleNumber}`, 'error');
                        return;
                    }
                }
                
                if (vehicleOutData.length === 0) {
                    showMessage(` WARNING: No OUT data found for vehicle ${vehicleNumber}`, 'error');
                    return;
                }
                
                // Group coils by vessel name for separate sections within the vehicle
                const vesselGroups = {};
                vehicleOutData.forEach(entry => {
                    const vesselName = entry['VESSEL NAME'] || 'N/A';
                    if (!vesselGroups[vesselName]) {
                        vesselGroups[vesselName] = [];
                    }
                    vesselGroups[vesselName].push(entry);
                });
                
                // Generate HTML table format with vessel grouping for vehicle report
                const currentDate = new Date().toLocaleDateString('en-GB').replace(/\//g, '-');
                const currentTime = new Date().toLocaleTimeString('en-US', { hour12: true });
                
                let content = `<div style="font-family: Arial, sans-serif; padding: 10px;">
                    <h3 style="text-align: center; margin-bottom: 5px;">A.S.Shipping Agencies Pvt Ltd,</h3>
                    <h4 style="text-align: center; margin-top: 0;">(Greenways Group)</h4>
                    <h3 style="text-align: center; color: #2c3e50;">GENERATE VEHICLE REPORT - ${vehicleNumber}${coilSerial ? ` (Serial: ${coilSerial})` : ''}</h3>
                    <p style="text-align: center; margin: 5px 0;">Generated on: ${currentDate} ${currentTime}</p>`;
                
                // Create sections for each vessel within this vehicle
                let totalVehicleWeight = 0;
                let totalVehicleCoils = 0;
                
                for (const [currentVesselName, vesselCoils] of Object.entries(vesselGroups)) {
                    const vesselTotalWeight = vesselCoils.reduce((sum, row) => {
                        return sum + (parseFloat(row['GROSS WT']) || 0);
                    }, 0);
                    
                    totalVehicleWeight += vesselTotalWeight;
                    totalVehicleCoils += vesselCoils.length;
                    
                    // Add vessel section header
                    content += `
                    <h4 style="text-align: center; margin-top: 20px; color: #2c3e50;">Vessel Name : ${currentVesselName}</h4>
                    
                    <table style="width: 100%; border-collapse: collapse; margin-top: 20px; font-size: 14px;">
                        <thead>
                            <tr style="background-color: #3498db; color: white;">
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: center; width: 10%;">Serial No</th>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: center; width: 20%;">Date & Time</th>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: center; width: 15%;">Transporter</th>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: center; width: 15%;">Vehicle No</th>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: center; width: 25%;">Coil No</th>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: center; width: 15%;">Gross WT</th>
                            </tr>
                        </thead>
                        <tbody>`;
                    
                    // Add data rows for this vessel - serial starts from 1 for each vessel
                    vesselCoils.forEach((row, index) => {
                        const bgColor = index % 2 === 0 ? '#f9f9f9' : '#ffffff';
                        const vesselSerialNo = index + 1; // Start from 1 for each vessel
                        content += `<tr style="background-color: ${bgColor};">
                            <td style="border: 1px solid #ddd; padding: 6px; text-align: center;">${vesselSerialNo}</td>
                            <td style="border: 1px solid #ddd; padding: 6px; text-align: center;">${row['DATE & TIME'] || ''}</td>
                            <td style="border: 1px solid #ddd; padding: 6px; text-align: center;">${row['TRANSPORTER'] || ''}</td>
                            <td style="border: 1px solid #ddd; padding: 6px; text-align: center;">${row['VEHICLE NO'] || ''}</td>
                            <td style="border: 1px solid #ddd; padding: 6px; text-align: center;">${row['MILL COIL NO'] || ''}</td>
                            <td style="border: 1px solid #ddd; padding: 6px; text-align: right;">${row['GROSS WT'] || ''}</td>
                        </tr>`;
                    });
                    
                    // Add vessel summary
                    content += `</tbody>
                            <tfoot>
                                <tr style="background-color: #2c3e50; color: white; font-weight: bold;">
                                    <td colspan="4" style="border: 1px solid #ddd; padding: 8px; text-align: center;">SUMMARY</td>
                                    <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">Total: ${vesselCoils.length}</td>
                                    <td style="border: 1px solid #ddd; padding: 8px; text-align: right;">${vesselTotalWeight.toFixed(2)}</td>
                                </tr>
                            </tfoot>
                        </table>`;
                }
                
                // Add overall vehicle summary
                content += `
                    <div style="margin-top: 20px; padding: 10px; background-color: #ecf0f1; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Vehicle Summary:</h4>
                        <p style="margin: 5px 0;"><strong>Total Records:</strong> ${totalVehicleCoils}</p>
                        <p style="margin: 5px 0;"><strong>Total Coils:</strong> ${totalVehicleCoils}</p>
                        <p style="margin: 5px 0;"><strong>Total Gross Weight:</strong> ${totalVehicleWeight.toFixed(2)}</p>
                        <p style="margin: 5px 0;"><strong>Number of Vessels:</strong> ${Object.keys(vesselGroups).length}</p>
                    </div>
                </div>`;
                
                // Always show in modal for better display
                showReportInModal(`Text Report - ${vehicleNumber}`, content);
                
                showMessage('Vehicle report generated successfully', 'success');
                
            } catch (error) {
                console.error('Error generating vehicle report:', error);
                showMessage('Error generating report: ' + error.message, 'error');
            }
        }

        // Vessel Summary Report - Provides summary statistics for each vessel
        async function generateVesselSummaryReport(event) {
            try {
                // Prevent any default form submission
                if (event) {
                    event.preventDefault();
                    event.stopPropagation();
                }
                
                showMessage('Generating vessel summary report...', 'info');
                
                // Load fresh data directly from Google Sheets (no localStorage for multi-user app)
                let reportData = [];
                try {
                    console.log('Loading fresh OUT data directly from Google Sheets for vessel summary...');
                    reportData = await window.googleSheetsAPI.loadOutSheetForReporting();
                    console.log('Fresh Google Sheets data loaded for vessel summary:', reportData.length, 'records');
                    
                    if (reportData.length === 0) {
                        // If no data from Google Sheets, try session data as fallback
                        reportData = window.outData || [];
                        console.log('Using session data as fallback for vessel summary:', reportData.length, 'records');
                    }
                } catch (error) {
                    console.error('Error loading fresh OUT data from Google Sheets for vessel summary:', error);
                    // Final fallback to session data only
                    reportData = window.outData || [];
                    console.log('Using session data as final fallback for vessel summary:', reportData.length, 'records');
                }
                
                if (reportData.length === 0) {
                    showMessage(' WARNING: No OUT data found to generate vessel summary', 'error');
                    return;
                }
                
                // Group data by vessel and calculate statistics
                const vesselStats = {};
                reportData.forEach(entry => {
                    const vesselName = entry['VESSEL NAME'] || 'N/A';
                    if (!vesselStats[vesselName]) {
                        vesselStats[vesselName] = {
                            totalCoils: 0,
                            totalWeight: 0,
                            vehicles: new Set(),
                            transporters: new Set(),
                            firstDate: null,
                            lastDate: null
                        };
                    }
                    
                    const stats = vesselStats[vesselName];
                    stats.totalCoils++;
                    stats.totalWeight += parseFloat(entry['GROSS WT']) || 0;
                    
                    if (entry['VEHICLE NO']) stats.vehicles.add(entry['VEHICLE NO']);
                    if (entry['TRANSPORTER']) stats.transporters.add(entry['TRANSPORTER']);
                    
                    const entryDate = new Date(entry['DATE & TIME'] || new Date());
                    if (!stats.firstDate || entryDate < stats.firstDate) stats.firstDate = entryDate;
                    if (!stats.lastDate || entryDate > stats.lastDate) stats.lastDate = entryDate;
                });
                
                // Generate summary report
                const currentDate = new Date().toLocaleDateString('en-GB').replace(/\//g, '-');
                const currentTime = new Date().toLocaleTimeString('en-US', { hour12: true });
                
                let content = `<div style="font-family: Arial, sans-serif; padding: 10px;">
                    <h3 style="text-align: center; margin-bottom: 5px;">A.S.Shipping Agencies Pvt Ltd,</h3>
                    <h4 style="text-align: center; margin-top: 0;">(Greenways Group)</h4>
                    <h3 style="text-align: center; color: #2c3e50;">VESSEL SUMMARY REPORT</h3>
                    <p style="text-align: center; margin: 5px 0;">Generated on: ${currentDate} ${currentTime}</p>
                    
                    <table style="width: 100%; border-collapse: collapse; margin-top: 20px; font-size: 14px;">
                        <thead>
                            <tr style="background-color: #3498db; color: white;">
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: center;">Vessel Name</th>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: center;">Total Coils</th>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: center;">Total Weight</th>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: center;">Vehicles Used</th>
                                <th style="border: 1px solid #ddd; padding: 8px; text-align: center;">Transporters</th>
                            </tr>
                        </thead>
                        <tbody>`;
                
                let totalCoils = 0;
                let totalWeight = 0;
                let rowIndex = 0;
                
                for (const [vesselName, stats] of Object.entries(vesselStats)) {
                    totalCoils += stats.totalCoils;
                    totalWeight += stats.totalWeight;
                    
                    const bgColor = rowIndex % 2 === 0 ? '#f9f9f9' : '#ffffff';
                    
                    content += `<tr style="background-color: ${bgColor};">
                        <td style="border: 1px solid #ddd; padding: 8px; text-align: center; font-weight: bold;">${vesselName}</td>
                        <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">${stats.totalCoils}</td>
                        <td style="border: 1px solid #ddd; padding: 8px; text-align: right;">${stats.totalWeight.toFixed(2)}</td>
                        <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">${stats.vehicles.size}</td>
                        <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">${stats.transporters.size}</td>
                    </tr>`;
                    rowIndex++;
                }
                
                content += `</tbody>
                        <tfoot>
                            <tr style="background-color: #2c3e50; color: white; font-weight: bold;">
                                <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">TOTAL</td>
                                <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">${totalCoils}</td>
                                <td style="border: 1px solid #ddd; padding: 8px; text-align: right;">${totalWeight.toFixed(2)}</td>
                                <td colspan="2" style="border: 1px solid #ddd; padding: 8px; text-align: center;">${Object.keys(vesselStats).length} Vessels</td>
                            </tr>
                        </tfoot>
                    </table>
                </div>`;
                
                // Store report data for PDF generation
                sessionStorage.setItem('currentReportData', JSON.stringify(reportData));
                
                showReportInModal('Vessel Summary Report', content);
                showMessage(`Vessel summary report generated - ${Object.keys(vesselStats).length} vessels analyzed`, 'success');
                
            } catch (error) {
                console.error('Error generating vessel summary report:', error);
                showMessage('Error generating vessel summary: ' + error.message, 'error');
            }
        }

        // Vessel-wise Detail Report - Provides detailed breakdown for each vessel separately
        async function generateVesselWiseDetailReport() {
            try {
                showMessage('Generating vessel-wise detail report...', 'info');
                
                // Load fresh data directly from Google Sheets (no localStorage for multi-user app)
                let reportData = [];
                
                try {
                    console.log('Loading fresh OUT data directly from Google Sheets for vessel detail...');
                    
                    // Load data directly from Google Sheets using the existing API
                    reportData = await window.googleSheetsAPI.loadOutSheetForReporting();
                    console.log('Fresh Google Sheets data loaded for vessel detail:', reportData.length, 'records');
                    
                    if (reportData.length === 0) {
                        // If no data from Google Sheets, try session data as fallback
                        reportData = window.outData || [];
                        console.log('Using session data as fallback for vessel detail:', reportData.length, 'records');
                    }
                    
                } catch (error) {
                    console.error('Error loading fresh OUT data from Google Sheets for vessel detail:', error);
                    // Final fallback to session data only
                    reportData = window.outData || [];
                    console.log('Using session data as final fallback for vessel detail:', reportData.length, 'records');
                }
                
                if (reportData.length === 0) {
                    showMessage(' WARNING: No OUT data found to generate vessel detail report', 'error');
                    return;
                }
                
                // Group coils by vessel name
                const vesselGroups = {};
                reportData.forEach(entry => {
                    const vesselName = entry['VESSEL NAME'] || 'N/A';
                    if (!vesselGroups[vesselName]) {
                        vesselGroups[vesselName] = [];
                    }
                    vesselGroups[vesselName].push(entry);
                });
                
                // Generate separate detailed report for each vessel
                const currentDate = new Date().toLocaleDateString('en-GB').replace(/\//g, '-');
                const currentTime = new Date().toLocaleTimeString('en-US', { hour12: true });
                
                let content = `<div style="font-family: Arial, sans-serif; padding: 10px;">
                    <h3 style="text-align: center; margin-bottom: 5px;">A.S.Shipping Agencies Pvt Ltd,</h3>
                    <h4 style="text-align: center; margin-top: 0;">(Greenways Group)</h4>
                    <h3 style="text-align: center; color: #2c3e50;">VESSEL-WISE DETAIL REPORT</h3>
                    <p style="text-align: center; margin: 5px 0;">Generated on: ${currentDate} ${currentTime}</p>`;
                
                let overallTotalWeight = 0;
                let overallTotalCoils = 0;
                
                // Create detailed sections for each vessel
                for (const [vesselName, vesselCoils] of Object.entries(vesselGroups)) {
                    const vesselTotalWeight = vesselCoils.reduce((sum, row) => sum + (parseFloat(row['GROSS WT']) || 0), 0);
                    overallTotalWeight += vesselTotalWeight;
                    overallTotalCoils += vesselCoils.length;
                    
                    // Group by vehicle within each vessel
                    const vehicleGroups = {};
                    vesselCoils.forEach(entry => {
                        const vehicleNo = entry['VEHICLE NO'] || 'N/A';
                        if (!vehicleGroups[vehicleNo]) {
                            vehicleGroups[vehicleNo] = [];
                        }
                        vehicleGroups[vehicleNo].push(entry);
                    });
                    
                    content += `
                    <div style="page-break-before: auto; margin-top: 30px;">
                        <h4 style="text-align: center; color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 5px;">
                             ${vesselName}
                        </h4>
                        <div style="text-align: center; margin: 10px 0; background-color: #ecf0f1; padding: 10px; border-radius: 5px;">
                            <strong>Vessel Summary:</strong> ${vesselCoils.length} Coils | ${vesselTotalWeight.toFixed(2)} Total Weight | ${Object.keys(vehicleGroups).length} Vehicles
                        </div>`;
                    
                    // Create a single table with continuous serial numbers (no vehicle headers)
                    content += `
                        <table style="width: 100%; border-collapse: collapse; margin: 10px 0; font-size: 12px;">
                            <thead>
                                <tr style="background-color: #3498db; color: white;">
                                    <th style="border: 1px solid #ddd; padding: 6px; text-align: center;">S.No</th>
                                    <th style="border: 1px solid #ddd; padding: 6px; text-align: center;">Date & Time</th>
                                    <th style="border: 1px solid #ddd; padding: 6px; text-align: center;">Vehicle No</th>
                                    <th style="border: 1px solid #ddd; padding: 6px; text-align: center;">Transporter</th>
                                    <th style="border: 1px solid #ddd; padding: 6px; text-align: center;">No of Coils</th>
                                    <th style="border: 1px solid #ddd; padding: 6px; text-align: center;">Gross WT</th>
                                </tr>
                            </thead>
                            <tbody>`;
                    
                    // Show each vehicle as a row with continuous serial numbers
                    let serialNumber = 1;
                    for (const [vehicleNo, vehicleCoils] of Object.entries(vehicleGroups)) {
                        const vehicleWeight = vehicleCoils.reduce((sum, row) => sum + (parseFloat(row['GROSS WT']) || 0), 0);
                        const bgColor = serialNumber % 2 === 0 ? '#f9f9f9' : '#ffffff';
                        const firstRow = vehicleCoils[0] || {};
                        
                        content += `<tr style="background-color: ${bgColor};">
                            <td style="border: 1px solid #ddd; padding: 4px; text-align: center;">${serialNumber}</td>
                            <td style="border: 1px solid #ddd; padding: 4px; text-align: center;">${firstRow['DATE & TIME'] || ''}</td>
                            <td style="border: 1px solid #ddd; padding: 4px; text-align: center;">${vehicleNo}</td>
                            <td style="border: 1px solid #ddd; padding: 4px; text-align: center;">${firstRow['TRANSPORTER'] || ''}</td>
                            <td style="border: 1px solid #ddd; padding: 4px; text-align: center;">${vehicleCoils.length}</td>
                            <td style="border: 1px solid #ddd; padding: 4px; text-align: right;">${vehicleWeight.toFixed(2)}</td>
                        </tr>`;
                        serialNumber++;
                    }
                    
                    content += `</tbody>
                        <tfoot>
                            <tr style="background-color: #2c3e50; color: white; font-weight: bold;">
                                <td colspan="4" style="border: 1px solid #ddd; padding: 8px; text-align: center;">VESSEL TOTAL</td>
                                <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">${vesselCoils.length}</td>
                                <td style="border: 1px solid #ddd; padding: 8px; text-align: right;">${vesselTotalWeight.toFixed(2)}</td>
                            </tr>
                        </tfoot>
                    </table>`;
                    
                    content += `</div>`;
                }
                
                // Add overall summary
                content += `
                    <div style="margin-top: 30px; padding: 15px; background-color: #2c3e50; color: white; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0; text-align: center;"> OVERALL SUMMARY</h4>
                        <div style="display: flex; justify-content: space-around; flex-wrap: wrap;">
                            <div style="text-align: center; margin: 5px;">
                                <strong>Total Vessels:</strong><br>${Object.keys(vesselGroups).length}
                            </div>
                            <div style="text-align: center; margin: 5px;">
                                <strong>Total Coils:</strong><br>${overallTotalCoils}
                            </div>
                            <div style="text-align: center; margin: 5px;">
                                <strong>Total Weight:</strong><br>${overallTotalWeight.toFixed(2)}
                            </div>
                        </div>
                    </div>
                </div>`;
                
                // Store report data for PDF generation
                sessionStorage.setItem('currentReportData', JSON.stringify(reportData));
                
                showReportInModal('Vessel-wise Detail Report', content);
                showMessage(`Vessel-wise detail report generated - ${Object.keys(vesselGroups).length} vessels with full breakdown`, 'success');
                
            } catch (error) {
                console.error('Error generating vessel-wise detail report:', error);
                showMessage('Error generating vessel detail report: ' + error.message, 'error');
            }
        }

        // APK Modal Functions - NEW FOR APK COMPATIBILITY
        function showReportInModal(title, content) {
            const modal = document.getElementById('reportModal');
            const modalTitle = document.getElementById('reportModalTitle');
            const modalContent = document.getElementById('reportModalContent');
            
            // Clear previous content first
            modalContent.innerHTML = '';
            modalTitle.textContent = '';
            
            // Use setTimeout to ensure DOM is ready
            setTimeout(() => {
                modalTitle.textContent = title;
                
                // Check if content is HTML or plain text
                if (content.includes('<table') || content.includes('<div')) {
                    modalContent.innerHTML = content;
                    modalContent.classList.remove('text-content');
                } else {
                    modalContent.textContent = content;
                    modalContent.classList.add('text-content');
                }
                
                // Ensure modal is visible and force reflow
                modal.classList.add('show');
                modal.style.display = 'flex';
                modal.style.visibility = 'visible';
                modal.style.opacity = '1';
                
                // Force browser to recalculate layout
                modal.offsetHeight;
                
                console.log('Modal shown with content length:', content.length);
                console.log('Modal content element:', modalContent);
                console.log('Modal display style:', modal.style.display);
                
            }, 100);
        }

        function closeReportModal() {
            const modal = document.getElementById('reportModal');
            modal.classList.remove('show');
            modal.style.display = 'none';
            modal.style.visibility = 'hidden';
            modal.style.opacity = '0';
        }

        // Print function for reports
        function printReport() {
            try {
                window.print();
                showMessage('Print dialog opened', 'success');
            } catch (error) {
                console.error('Error printing report:', error);
                showMessage('Error opening print dialog: ' + error.message, 'error');
            }
        }

        // Enhanced PDF download function with Google Drive storage for mobile/APK compatibility
        async function downloadReportAsPDF() {
            const pdfBtn = document.querySelector('.report-modal-pdf');
            
            try {
                const title = document.getElementById('reportModalTitle').textContent;
                const modalContent = document.getElementById('reportModalContent');
                
                // Show user feedback immediately
                if (pdfBtn) {
                    pdfBtn.textContent = 'Generating...';
                    pdfBtn.disabled = true;
                    pdfBtn.classList.add('pdf-generating');
                }
                
                // Check if jsPDF is available with multiple fallback methods
                let jsPDF;
                if (window.jspdf && window.jspdf.jsPDF) {
                    jsPDF = window.jspdf.jsPDF;
                } else if (window.jsPDF) {
                    jsPDF = window.jsPDF;
                } else {
                    throw new Error('PDF library not loaded. Please refresh and try again.');
                }
                
                console.log('jsPDF loaded successfully:', typeof jsPDF);
                const isDetailReport = title.includes('Detail') || title.includes('ALL OUT');
                const doc = new jsPDF('p', 'mm', 'a4'); // Always use A4 portrait
                
                // Get page dimensions and set up header
                const pageWidth = doc.internal.pageSize.getWidth();
                const centerX = pageWidth / 2;
                
                // Add header with reduced gaps
                doc.setFontSize(12);
                doc.setFont(undefined, 'bold');
                doc.text('A.S.Shipping Agencies Pvt Ltd', centerX, 15, { align: 'center' });
                doc.text('(Greenways Group)', centerX, 22, { align: 'center' });
                
                // Add title
                doc.setFontSize(11);
                doc.setFont(undefined, 'bold');
                doc.text(title, centerX, 32, { align: 'center' });
                
                // Add generation date
                doc.setFontSize(9);
                doc.setFont(undefined, 'normal');
                const currentDate = new Date().toLocaleDateString('en-GB').replace(/\//g, '-');
                const currentTime = new Date().toLocaleTimeString('en-US', { hour12: true });
                doc.text(`Generated on: ${currentDate} ${currentTime}`, centerX, 38, { align: 'center' });
                
                let yPosition = 45;
                
                // Generate PDF with proper table formatting that matches HTML
                if (modalContent.innerHTML.includes('<table')) {
                    // Check if autoTable plugin is available for better table rendering
                    if (doc.autoTable) {
                        // Use autoTable for professional table formatting
                        const tables = modalContent.querySelectorAll('table');
                        
                        tables.forEach((table, tableIndex) => {
                            if (tableIndex > 0) {
                                yPosition += 10; // Reduced space between tables
                            }
                            
                            // Extract vessel information from preceding headings - enhanced detection
                            let vesselName = '';
                            let vesselSummary = '';
                            
                            // Look for vessel heading in multiple ways
                            let searchElement = table.previousElementSibling;
                            let searchDepth = 0;
                            
                            while (searchElement && searchDepth < 5) {
                                const textContent = searchElement.textContent;
                                
                                // Check for vessel name patterns
                                if (textContent.includes('') || textContent.includes('VESSEL') || 
                                    textContent.includes('M.V.') || textContent.includes('V.')) {
                                    vesselName = textContent.replace('', '').trim();
                                    break;
                                }
                                
                                // Check for vessel summary
                                if (textContent.includes('Vessel Summary:') || textContent.includes('Total Weight')) {
                                    vesselSummary = textContent;
                                }
                                
                                searchElement = searchElement.previousElementSibling;
                                searchDepth++;
                            }
                            
                            // Add vessel name if found
                            if (vesselName) {
                                // Check if we need a new page for vessel section
                                if (yPosition > doc.internal.pageSize.height - 40) {
                                    doc.addPage();
                                    yPosition = 15;
                                }
                                
                                doc.setFontSize(10);
                                doc.setFont(undefined, 'bold');
                                doc.setTextColor(0, 0, 0); // Black color
                                // Remove vessel emoji from PDF display
                                const cleanVesselName = vesselName.replace('', '').trim();
                                doc.text(cleanVesselName, centerX, yPosition, { align: 'center' });
                                yPosition += 6;
                                
                                // Add vessel summary if found
                                if (vesselSummary) {
                                    doc.setFontSize(9);
                                    doc.setFont(undefined, 'normal');
                                    doc.setTextColor(0, 0, 0);
                                    doc.text(vesselSummary, centerX, yPosition, { align: 'center' });
                                    yPosition += 5;
                                }
                            }
                            
                            // Extract headers
                            const headerRow = table.querySelector('thead tr');
                            const headers = [];
                            if (headerRow) {
                                headerRow.querySelectorAll('th').forEach(th => {
                                    headers.push(th.textContent.trim());
                                });
                            }
                            
                            // Extract data rows
                            const dataRows = [];
                            const bodyRows = table.querySelectorAll('tbody tr');
                            bodyRows.forEach(row => {
                                const rowData = [];
                                row.querySelectorAll('td').forEach(td => {
                                    rowData.push(td.textContent.trim());
                                });
                                if (rowData.length > 0) {
                                    dataRows.push(rowData);
                                }
                            });
                            
                            // Extract footer data
                            const footerRows = [];
                            const footerRow = table.querySelector('tfoot tr');
                            if (footerRow) {
                                const footerData = [];
                                footerRow.querySelectorAll('td').forEach(td => {
                                    footerData.push(td.textContent.trim());
                                });
                                if (footerData.length > 0) {
                                    footerRows.push(footerData);
                                }
                            }
                            
                            // Configure autoTable with better sizing and page break settings
                            const tableConfig = {
                                head: headers.length > 0 ? [headers] : [],
                                body: dataRows,
                                foot: footerRows,
                                startY: yPosition,
                                theme: 'grid',
                                headStyles: {
                                    fillColor: [52, 152, 219], // Blue header
                                    textColor: [255, 255, 255],
                                    fontSize: 9,
                                    fontStyle: 'bold',
                                    halign: 'center',
                                    cellPadding: 2
                                },
                                bodyStyles: {
                                    fontSize: 8,
                                    cellPadding: 2,
                                    overflow: 'linebreak',
                                    cellWidth: 'wrap'
                                },
                                footStyles: {
                                    fillColor: [44, 62, 80], // Dark footer
                                    textColor: [255, 255, 255],
                                    fontSize: 9,
                                    fontStyle: 'bold',
                                    halign: 'center',
                                    cellPadding: 2
                                },
                                alternateRowStyles: {
                                    fillColor: [249, 249, 249]
                                },
                                margin: { left: 10, right: 10 },
                                tableWidth: 'auto',
                                columnStyles: {},
                                showHead: 'everyPage', // Show header on every page
                                showFoot: 'lastPage',   // Show footer only on last page
                                styles: {
                                    overflow: 'linebreak',
                                    cellWidth: 'wrap',
                                    fontSize: 8
                                }
                            };
                            
                            // Right-align the last column (usually weight)
                            if (headers.length > 0) {
                                tableConfig.columnStyles[headers.length - 1] = { halign: 'right' };
                            }
                            
                            // Generate the table
                            doc.autoTable(tableConfig);
                            yPosition = doc.lastAutoTable.finalY + 8;
                        });
                        
                        // Add summary sections after all tables - enhanced to capture all summary styles
                        const summaryDivs = modalContent.querySelectorAll(
                            'div[style*="background-color: #ecf0f1"], div[style*="background-color:#ecf0f1"], ' +
                            'div[style*="background-color: #2c3e50"], div[style*="background-color:#2c3e50"]'
                        );
                        
                        summaryDivs.forEach(div => {
                            const summaryTitle = div.querySelector('h4');
                            if (summaryTitle && (summaryTitle.textContent.includes('Summary') || summaryTitle.textContent.includes('SUMMARY') || summaryTitle.textContent.includes('OVERALL'))) {
                                // Check if we need a new page
                                if (yPosition > doc.internal.pageSize.height - 40) {
                                    doc.addPage();
                                    yPosition = 15;
                                }
                                
                                // Add summary section header with matching HTML style
                                doc.setFontSize(11);
                                doc.setFont(undefined, 'bold');
                                
                                // Use different colors based on summary type
                                if (summaryTitle.textContent.includes('OVERALL')) {
                                    // Add extra gap before OVERALL SUMMARY
                                    yPosition += 8;
                                    doc.setTextColor(0, 0, 0); // Black text for overall summary
                                    // Add dark background rectangle for overall summary
                                    doc.setFillColor(44, 62, 80);
                                    doc.rect(20, yPosition - 8, pageWidth - 40, 20, 'F');
                                    // Remove chart emoji from title
                                    const cleanTitle = summaryTitle.textContent.replace('', '').trim();
                                    doc.text(cleanTitle, centerX, yPosition, { align: 'center' });
                                } else {
                                    doc.setTextColor(44, 62, 80); // Dark blue for regular summaries
                                    // Remove chart emoji from title for regular summaries too
                                    const cleanTitle = summaryTitle.textContent.replace('', '').trim();
                                    doc.text(cleanTitle, 20, yPosition);
                                }
                                
                                yPosition += 10;
                                
                                // Add summary details - set black color for visibility
                                doc.setFontSize(9);
                                doc.setFont(undefined, 'normal');
                                doc.setTextColor(0, 0, 0); // Black text for visibility
                                
                                // Handle flex layout summaries (like overall summary)
                                const flexDiv = div.querySelector('div[style*="display: flex"]');
                                if (flexDiv) {
                                    const summaryItems = flexDiv.querySelectorAll('div');
                                    let xPos = 20;
                                    const itemWidth = (pageWidth - 40) / summaryItems.length;
                                    
                                    summaryItems.forEach((item, index) => {
                                        const text = item.textContent.trim();
                                        if (text) {
                                            // Set black text color for visibility
                                            doc.setTextColor(0, 0, 0);
                                            // Split by line breaks and handle multi-line items
                                            const lines = text.split('\n').filter(line => line.trim());
                                            lines.forEach((line, lineIndex) => {
                                                doc.text(line.trim(), xPos + (itemWidth * index), yPosition + (lineIndex * 6), { 
                                                    align: 'left',
                                                    maxWidth: itemWidth - 10
                                                });
                                            });
                                        }
                                    });
                                    yPosition += Math.max(15, summaryItems.length > 0 ? 20 : 15);
                                } else {
                                    // Handle regular paragraph summaries
                                    const summaryParagraphs = div.querySelectorAll('p');
                                    summaryParagraphs.forEach(p => {
                                        const text = p.textContent.trim();
                                        if (text) {
                                            // Set black text color for visibility
                                            doc.setTextColor(0, 0, 0);
                                            doc.text(text, 20, yPosition);
                                            yPosition += 7;
                                        }
                                    });
                                }
                                
                                yPosition += 10; // Extra gap after summary
                            }
                        });
                    } else {
                        // Simple PDF generation without autoTable plugin
                        console.log('Using simple PDF generation without autoTable');
                        
                        // Create a simplified table view from the HTML content
                        const tables = modalContent.querySelectorAll('table');
                        
                        tables.forEach((table, tableIndex) => {
                            if (tableIndex > 0) {
                                // Add page break if needed
                                if (yPosition > doc.internal.pageSize.height - 50) {
                                    doc.addPage();
                                    yPosition = 20;
                                }
                                yPosition += 20;
                            }
                            
                            // Extract and render table data manually
                            const headerRow = table.querySelector('thead tr');
                            const bodyRows = table.querySelectorAll('tbody tr');
                            const footerRow = table.querySelector('tfoot tr');
                            
                            // Calculate column widths based on content
                            const colCount = headerRow ? headerRow.querySelectorAll('th').length : 6;
                            const availableWidth = pageWidth - 20; // Smaller margins
                            
                            // Dynamic column widths to prevent overlapping
                            let colWidths = [];
                            if (headerRow) {
                                const headers = Array.from(headerRow.querySelectorAll('th')).map(th => th.textContent.trim());
                                const baseWidth = availableWidth / (colCount + 1); // Extra space buffer
                                colWidths = headers.map((header, i) => {
                                    if (header.toLowerCase().includes('sl') || header.toLowerCase().includes('sr') || header.toLowerCase().includes('no')) {
                                        return baseWidth * 0.6; // Narrower for serial numbers
                                    } else if (header.toLowerCase().includes('weight') || header.toLowerCase().includes('wt')) {
                                        return baseWidth * 1.3; // Wider for weight columns
                                    } else {
                                        return baseWidth; // Standard width
                                    }
                                });
                            } else {
                                const colWidth = availableWidth / colCount;
                                colWidths = new Array(colCount).fill(colWidth);
                            }
                            
                            let currentY = yPosition;
                            
                            // Draw header
                            if (headerRow) {
                                const headers = Array.from(headerRow.querySelectorAll('th')).map(th => th.textContent.trim());
                                
                                // Header background
                                doc.setFillColor(52, 152, 219);
                                doc.rect(15, currentY, availableWidth, 8, 'F');
                                
                                // Header text
                                doc.setTextColor(0, 0, 0);
                                doc.setFontSize(10);
                                doc.setFont(undefined, 'bold');
                                
                                headers.forEach((header, i) => {
                                    const x = 15 + colWidths.slice(0, i).reduce((sum, w) => sum + w, 0) + (colWidths[i] / 2);
                                    doc.text(header, x, currentY + 5, { align: 'center' });
                                });
                                
                                currentY += 8;
                            }
                            
                            // Draw body rows with page break support
                            bodyRows.forEach((row, rowIndex) => {
                                // Check if we need a new page
                                if (currentY > doc.internal.pageSize.height - 40) {
                                    doc.addPage();
                                    currentY = 20;
                                    
                                    // Re-draw header on new page
                                    const headers = Array.from(headerRow.querySelectorAll('th')).map(th => th.textContent.trim());
                                    doc.setFillColor(52, 152, 219);
                                    doc.rect(15, currentY, availableWidth, 8, 'F');
                                    
                                    doc.setTextColor(0, 0, 0);
                                    doc.setFontSize(8);
                                    doc.setFont(undefined, 'bold');
                                    
                                    headers.forEach((header, i) => {
                                        const x = 15 + colWidths.slice(0, i).reduce((sum, w) => sum + w, 0) + (colWidths[i] / 2);
                                        doc.text(header, x, currentY + 5, { align: 'center' });
                                    });
                                    currentY += 8;
                                }
                                
                                const cells = Array.from(row.querySelectorAll('td')).map(td => td.textContent.trim());
                                
                                // Alternating row colors
                                if (rowIndex % 2 === 0) {
                                    doc.setFillColor(249, 249, 249);
                                    doc.rect(15, currentY, availableWidth, 5, 'F');
                                }
                                
                                // Cell borders
                                doc.setDrawColor(221, 221, 221);
                                let xPos = 15;
                                for (let i = 0; i < colCount; i++) {
                                    doc.rect(xPos, currentY, colWidths[i], 5);
                                    xPos += colWidths[i];
                                }
                                
                                // Cell text
                                doc.setTextColor(0, 0, 0);
                                doc.setFontSize(7);
                                doc.setFont(undefined, 'normal');
                                
                                cells.forEach((cell, i) => {
                                    const xStart = 15 + colWidths.slice(0, i).reduce((sum, w) => sum + w, 0);
                                    const x = xStart + 2;
                                    const align = (i === cells.length - 1) ? 'right' : 'left'; // Right align last column
                                    const textX = align === 'right' ? xStart + colWidths[i] - 2 : x;
                                    
                                    // Truncate text if too long to prevent overflow
                                    let displayText = cell;
                                    if (doc.getTextWidth(displayText) > colWidths[i] - 4) {
                                        while (doc.getTextWidth(displayText + '...') > colWidths[i] - 4 && displayText.length > 0) {
                                            displayText = displayText.slice(0, -1);
                                        }
                                        displayText += '...';
                                    }
                                    
                                    doc.text(displayText, textX, currentY + 3.5, { align: align });
                                });
                                
                                currentY += 5;
                            });
                            
                            // Draw footer
                            if (footerRow) {
                                const footerCells = Array.from(footerRow.querySelectorAll('td')).map(td => td.textContent.trim());
                                
                                // Footer background
                                doc.setFillColor(44, 62, 80);
                                doc.rect(15, currentY, availableWidth, 8, 'F');
                                
                                // Footer text
                                doc.setTextColor(0, 0, 0);
                                doc.setFontSize(10);
                                doc.setFont(undefined, 'bold');
                                
                                let cellIndex = 0;
                                footerCells.forEach((cell, i) => {
                                    const colspan = footerRow.querySelectorAll('td')[i].getAttribute('colspan') || 1;
                                    const cellWidth = colWidth * parseInt(colspan);
                                    const x = 15 + (cellIndex * colWidth);
                                    const centerX = x + (cellWidth / 2);
                                    
                                    doc.text(cell, centerX, currentY + 5, { align: 'center' });
                                    cellIndex += parseInt(colspan);
                                });
                                
                                currentY += 8;
                            }
                            
                            yPosition = currentY + 10;
                        });
                        
                        // Add summary sections for manual table drawing - enhanced for overall summaries
                        const summaryDivs = modalContent.querySelectorAll('div[style*="background-color: #ecf0f1"], div[style*="background-color:#ecf0f1"], div[style*="background-color: #2c3e50"], div[style*="background-color:#2c3e50"]');
                        summaryDivs.forEach(div => {
                            const summaryTitle = div.querySelector('h4');
                            if (summaryTitle && (summaryTitle.textContent.includes('Summary') || summaryTitle.textContent.includes('SUMMARY') || summaryTitle.textContent.includes(''))) {
                                // Check if we need a new page
                                if (yPosition > doc.internal.pageSize.height - 60) {
                                    doc.addPage();
                                    yPosition = 20;
                                }
                                
                                // Add summary section header with dark background for OVERALL SUMMARY
                                doc.setFontSize(12);
                                doc.setFont(undefined, 'bold');
                                // Remove chart emoji from title in simple PDF generation
                                const cleanTitle = summaryTitle.textContent.replace('', '').trim();
                                
                                // Check if it's OVERALL SUMMARY and add dark background
                                if (cleanTitle.includes('OVERALL')) {
                                    // Add dark background rectangle for overall summary
                                    doc.setFillColor(44, 62, 80);
                                    doc.rect(20, yPosition - 8, pageWidth - 40, 80, 'F'); // Larger height for content
                                    doc.setTextColor(0, 0, 0); // Black text
                                } else {
                                    doc.setTextColor(0, 0, 0); // Black text for regular summaries
                                }
                                
                                doc.text(cleanTitle, centerX, yPosition, { align: 'center' });
                                yPosition += 12;
                                
                                // Extract and format summary details
                                doc.setFontSize(10);
                                doc.setFont(undefined, 'normal');
                                doc.setTextColor(0, 0, 0);
                                
                                // Look for specific summary data patterns
                                const summaryText = div.textContent;
                                
                                // Extract statistics from the summary
                                if (summaryText.includes('Total Vessels:') || summaryText.includes('Total Coils:') || summaryText.includes('Total Weight:')) {
                                    const vesselMatch = summaryText.match(/Total Vessels:\s*(\d+)/);
                                    const coilMatch = summaryText.match(/Total Coils:\s*(\d+)/);
                                    const weightMatch = summaryText.match(/Total Weight:\s*([\d.]+)/);
                                    
                                    // Set black color for visibility
                                    doc.setTextColor(0, 0, 0);
                                    
                                    if (vesselMatch) {
                                        doc.setTextColor(0, 0, 0); // Black text for visibility
                                        doc.text(`Total Vessels: ${vesselMatch[1]}`, centerX, yPosition, { align: 'center' });
                                        yPosition += 8;
                                    }
                                    if (coilMatch) {
                                        doc.setTextColor(0, 0, 0); // Black text for visibility
                                        doc.text(`Total Coils: ${coilMatch[1]}`, centerX, yPosition, { align: 'center' });
                                        yPosition += 8;
                                    }
                                    if (weightMatch) {
                                        doc.setTextColor(0, 0, 0); // Black text for visibility
                                        doc.text(`Total Weight: ${weightMatch[1]}`, centerX, yPosition, { align: 'center' });
                                        yPosition += 8;
                                    }
                                } else {
                                    // Fallback - extract all meaningful lines
                                    const lines = summaryText.split('\n').filter(line => line.trim());
                                    // Set black color for visibility
                                    doc.setTextColor(0, 0, 0);
                                    lines.forEach(line => {
                                        const cleanLine = line.trim();
                                        if (cleanLine && !cleanLine.includes('') && cleanLine.length > 3 && !cleanLine.includes('SUMMARY')) {
                                            doc.setTextColor(0, 0, 0); // Black text for visibility
                                            doc.text(cleanLine, centerX, yPosition, { align: 'center' });
                                            yPosition += 6;
                                        }
                                    });
                                }
                                yPosition += 10; // Gap after summary
                            }
                        });
                    }
                } else {
                    // Handle plain text content - create simplified table from text
                    doc.setFontSize(8);
                    doc.setFont(undefined, 'normal');
                    
                    const textContent = modalContent.textContent || modalContent.innerText;
                    const lines = textContent.split('\n').filter(line => line.trim());
                    
                    lines.forEach(line => {
                        // Check for page break
                        if (yPosition > doc.internal.pageSize.height - 30) {
                            doc.addPage();
                            yPosition = 20;
                        }
                        
                        const wrappedLines = doc.splitTextToSize(line.trim(), pageWidth - 40);
                        doc.text(wrappedLines, 20, yPosition);
                        yPosition += (wrappedLines.length * 6) + 2;
                    });
                }
                
                // Generate mobile-friendly filename for consistent overwriting
                const cleanTitle = title.replace(/[^a-z0-9\s]/gi, '').replace(/\s+/g, '_').toLowerCase();
                const timestamp = new Date().toISOString().slice(0, 10).replace(/-/g, '');
                const filename = `${cleanTitle}_${timestamp}.pdf`;
                
                console.log('Processing PDF with filename:', filename);
                
                // Generate PDF blob
                const pdfBlob = doc.output('blob');
                
                // Initialize Google Drive API if not already done
                if (!googleDriveManager.isInitialized) {
                    if (pdfBtn) pdfBtn.textContent = 'Initializing Drive...';
                    await googleDriveManager.initialize();
                }
                
                // Try to upload to Google Drive first
                try {
                    if (googleDriveManager.isInitialized) {
                        if (pdfBtn) pdfBtn.textContent = 'Uploading to Drive...';
                        
                        const driveResult = await googleDriveManager.uploadPDF(pdfBlob, filename);
                        
                        if (driveResult && driveResult.webViewLink) {
                            // Success: PDF uploaded to Google Drive
                            console.log('PDF uploaded to Google Drive:', driveResult);
                            
                            // Show success message with option to view
                            const viewLink = driveResult.webViewLink;
                            showMessage(`PDF saved to Google Drive successfully! File: ${filename}`, 'success');
                            
                            // For mobile APK: Open the PDF directly from Google Drive
                            if (window.cordova || navigator.userAgent.includes('wv')) {
                                // Mobile APK environment - open PDF directly
                                window.open(viewLink, '_blank');
                            } else {
                                // Browser environment - ask user if they want to view
                                setTimeout(() => {
                                    if (confirm('PDF uploaded to Google Drive! Would you like to view it now?')) {
                                        window.open(viewLink, '_blank');
                                    }
                                }, 1000);
                            }
                            
                            return; // Exit successfully
                        }
                    }
                } catch (driveError) {
                    console.log('Google Drive upload failed, falling back to local download:', driveError.message);
                    if (pdfBtn) pdfBtn.textContent = 'Downloading locally...';
                }
                
                // Fallback to local download if Google Drive fails
                try {
                    // Try primary save method
                    doc.save(filename);
                    console.log('PDF saved locally using doc.save()');
                    showMessage('PDF downloaded locally! Check your Downloads folder', 'success');
                } catch (saveError) {
                    console.warn('Primary save failed, trying blob method:', saveError);
                    
                    // Fallback to blob method
                    const url = URL.createObjectURL(pdfBlob);
                    
                    const downloadLink = document.createElement('a');
                    downloadLink.href = url;
                    downloadLink.download = filename;
                    downloadLink.style.display = 'none';
                    document.body.appendChild(downloadLink);
                    
                    // Force click and download
                    downloadLink.click();
                    
                    // Clean up after delay
                    setTimeout(() => {
                        if (document.body.contains(downloadLink)) {
                            document.body.removeChild(downloadLink);
                        }
                        URL.revokeObjectURL(url);
                    }, 1000);
                    
                    console.log('PDF saved locally using blob method');
                    showMessage('PDF downloaded locally via fallback method! Check your Downloads folder', 'success');
                }
                
            } catch (error) {
                console.error('Error generating PDF:', error);
                
                // Provide more specific error messages for mobile users
                let errorMessage = 'Error generating PDF: ';
                if (error.message.includes('not loaded')) {
                    errorMessage += 'PDF library not available. Please refresh the page and try again.';
                } else if (error.message.includes('quota')) {
                    errorMessage += 'Storage space full. Please free up space and try again.';
                } else {
                    errorMessage += error.message;
                }
                
                showMessage(errorMessage, 'error');
                
            } finally {
                // Reset button state
                const pdfBtn = document.querySelector('.report-modal-pdf');
                if (pdfBtn) {
                    pdfBtn.textContent = 'PDF';
                    pdfBtn.disabled = false;
                    pdfBtn.classList.remove('pdf-generating');
                }
            }
        }

        // Enhanced Share functionality for APK compatibility
        async function shareReport() {
            try {
                const title = document.getElementById('reportModalTitle').textContent;
                const modalContent = document.getElementById('reportModalContent');
                
                // Extract text content from HTML or get plain text
                let content;
                if (modalContent.innerHTML.includes('<table')) {
                    // Convert HTML table to plain text format
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = modalContent.innerHTML;
                    
                    // Remove HTML tags and format as plain text
                    const tables = tempDiv.querySelectorAll('table');
                    let textContent = '';
                    
                    if (tables.length > 0) {
                        const table = tables[0];
                        const rows = table.querySelectorAll('tr');
                        
                        // Add header info
                        const headers = tempDiv.querySelectorAll('h3, h4, p');
                        headers.forEach(header => {
                            if (header.closest('table')) return; // Skip headers inside tables
                            textContent += header.textContent.trim() + '\n';
                        });
                        textContent += '\n';
                        
                        // Process table rows
                        rows.forEach((row, index) => {
                            const cells = row.querySelectorAll('th, td');
                            const rowText = Array.from(cells).map(cell => cell.textContent.trim()).join('\t');
                            textContent += rowText + '\n';
                            
                            // Add separator after header row
                            if (index === 0 && row.querySelector('th')) {
                                textContent += '='.repeat(80) + '\n';
                            }
                        });
                        
                        // Add summary section
                        const summaryDiv = tempDiv.querySelector('div');
                        if (summaryDiv && !summaryDiv.querySelector('table')) {
                            textContent += '\n' + summaryDiv.textContent.trim();
                        }
                    }
                    
                    content = textContent;
                } else {
                    content = modalContent.textContent;
                }
                
                // Show user feedback immediately
                const shareBtn = document.querySelector('.report-modal-share');
                if (shareBtn) {
                    shareBtn.textContent = 'Sharing...';
                    shareBtn.disabled = true;
                }
                
                // Method 1: Enhanced Android WebView Interface (APK environment)
                if (typeof Android !== 'undefined' && Android.shareText) {
                    try {
                        Android.shareText(title, content);
                        showMessage('Report shared successfully', 'success');
                        return;
                    } catch (error) {
                        console.log('Android WebView share failed:', error);
                    }
                }
                
                // Method 2: Enhanced Android Intent handling
                if (window.AndroidInterface && window.AndroidInterface.share) {
                    try {
                        window.AndroidInterface.share(title, content);
                        showMessage('Report shared successfully', 'success');
                        return;
                    } catch (error) {
                        console.log('AndroidInterface share failed:', error);
                    }
                }
                
                // Method 3: Web Share API with enhanced mobile support
                if (navigator.share) {
                    try {
                        // First try with just text (most compatible)
                        await navigator.share({
                            title: title,
                            text: content
                        });
                        showMessage('Report shared successfully', 'success');
                        return;
                    } catch (error) {
                        console.log('Web Share API failed:', error);
                        // Continue to next method instead of stopping
                    }
                }
                
                // Method 4: Create and share file (mobile-optimized)
                if (navigator.share && typeof File !== 'undefined') {
                    try {
                        const timestamp = new Date().toISOString().slice(0, 10);
                        const fileName = `${title.replace(/[^a-z0-9]/gi, '_')}_${timestamp}.txt`;
                        const blob = new Blob([`${title}\n\n${content}`], { type: 'text/plain' });
                        const file = new File([blob], fileName, { type: 'text/plain' });
                        
                        await navigator.share({
                            title: title,
                            files: [file]
                        });
                        showMessage('Report file shared successfully', 'success');
                        return;
                    } catch (error) {
                        console.log('File share method failed:', error);
                    }
                }
                
                // Method 5: Enhanced Clipboard API for mobile
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    try {
                        const shareText = `${title}\n\n${content}`;
                        await navigator.clipboard.writeText(shareText);
                        showMessage('Report copied to clipboard successfully! You can now paste it in any messaging app', 'success');
                        return;
                    } catch (error) {
                        console.log('Modern clipboard API failed:', error);
                    }
                }
                
                // Method 6: Force download with mobile optimization
                try {
                    const timestamp = new Date().toISOString().slice(0, 10);
                    const fileName = `${title.replace(/[^a-z0-9]/gi, '_')}_${timestamp}.txt`;
                    const shareText = `${title}\n\n${content}`;
                    const blob = new Blob([shareText], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    
                    // For mobile devices, create a more visible download link
                    const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                    
                    if (isMobile) {
                        const downloadLink = document.createElement('a');
                        downloadLink.href = url;
                        downloadLink.download = fileName;
                        downloadLink.style.display = 'none';
                        document.body.appendChild(downloadLink);
                        
                        // Trigger download
                        downloadLink.click();
                        
                        // Clean up
                        setTimeout(() => {
                            document.body.removeChild(downloadLink);
                            URL.revokeObjectURL(url);
                        }, 100);
                        
                        showMessage('Report downloaded successfully! Check your Downloads folder to share the file', 'success');
                        return;
                    } else {
                        // Desktop fallback
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = fileName;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        showMessage('Report downloaded - you can share the file from your downloads', 'success');
                        return;
                    }
                } catch (error) {
                    console.log('Download method failed:', error);
                }
                
                // Method 7: Enhanced fallback with better mobile handling
                try {
                    const shareText = `${title}\n\n${content}`;
                    
                    // Try modern clipboard first for mobile
                    if (navigator.clipboard) {
                        try {
                            await navigator.clipboard.writeText(shareText);
                            showMessage('Report copied to clipboard! You can now paste it in any app to share', 'success');
                            return;
                        } catch (clipError) {
                            console.log('Modern clipboard failed, trying legacy method');
                        }
                    }
                    
                    // Legacy clipboard method with mobile optimization
                    const textArea = document.createElement('textarea');
                    textArea.value = shareText;
                    textArea.style.position = 'fixed';
                    textArea.style.top = '50%';
                    textArea.style.left = '50%';
                    textArea.style.transform = 'translate(-50%, -50%)';
                    textArea.style.width = '90%';
                    textArea.style.height = '200px';
                    textArea.style.padding = '10px';
                    textArea.style.border = '2px solid #3498db';
                    textArea.style.borderRadius = '8px';
                    textArea.style.background = 'white';
                    textArea.style.color = '#2c3e50';
                    textArea.style.fontSize = '14px';
                    textArea.style.fontFamily = 'monospace';
                    textArea.style.zIndex = '10000';
                    textArea.setAttribute('readonly', true);
                    
                    document.body.appendChild(textArea);
                    textArea.focus();
                    textArea.select();
                    
                    // For mobile, show instructions
                    const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                    if (isMobile) {
                        showMessage('Please select all text and copy it to share the report', 'info');
                        
                        // Auto-remove after 10 seconds
                        setTimeout(() => {
                            if (document.body.contains(textArea)) {
                                document.body.removeChild(textArea);
                            }
                        }, 10000);
                    } else {
                        try {
                            const successful = document.execCommand('copy');
                            document.body.removeChild(textArea);
                            if (successful) {
                                showMessage('Report copied to clipboard! You can now paste it in any app to share', 'success');
                            } else {
                                showMessage('Please manually copy the report text to share', 'info');
                            }
                        } catch (error) {
                            document.body.removeChild(textArea);
                            showMessage('Please manually copy the report text to share', 'info');
                        }
                    }
                    
                } catch (error) {
                    console.log('Fallback method failed:', error);
                    showMessage('Unable to share report automatically. Please copy the text manually', 'error');
                }
                
            } catch (error) {
                console.error('All share methods failed:', error);
                showMessage('Unable to share report. Please copy the text manually', 'error');
            } finally {
                // Reset button state
                const shareBtn = document.querySelector('.report-modal-share');
                if (shareBtn) {
                    shareBtn.textContent = 'Share';
                    shareBtn.disabled = false;
                }
            }
        }



        async function uploadExcel() {
            try {
                const fileInput = document.getElementById('excelFile') || document.querySelector('input[type="file"]');
                if (!fileInput) {
                    showMessage('No file input available - please use Google Sheets integration', 'error');
                    return;
                }
                
                const file = fileInput.files[0];
                if (!file) {
                    showMessage(' WARNING: Please select an Excel file to upload', 'error');
                    return;
                }
                
                showMessage('Processing Excel file for Google Sheets...', 'info');
                
                // Read the file as array buffer
                const arrayBuffer = await file.arrayBuffer();
                const uint8Array = new Uint8Array(arrayBuffer);
                
                // Convert to base64 for processing
                const base64String = btoa(String.fromCharCode(...uint8Array));
                
                // Process with Google Sheets integration
                const result = await window.googleSheetsAPI.uploadExcelFile(base64String, file.name);
                
                if (result.success) {
                    showMessage(`Excel file "${file.name}" processed successfully`, 'success');
                    
                    // Clear the file input
                    fileInput.value = '';
                    document.getElementById('fileName').textContent = '';
                    
                    // Optionally refresh the coil data from the uploaded file
                    await loadCoilDataFromFile();
                } else {
                    showMessage(`Error uploading Excel file: ${result.error}`, 'error');
                }
                
            } catch (error) {
                console.error('Error uploading Excel file:', error);
                showMessage('Error uploading Excel file: ' + error.message, 'error');
            }
        }

        function clearInputs() {
            document.getElementById('coilInput').value = '';
            document.getElementById('suggestions').style.display = 'none';
            toggleClearButton();
            // Close coil modal if it's open
            const modal = document.getElementById('coilModal');
            if (modal && modal.classList.contains('show')) {
                closeCoilModal();
            }
        }

        function clearLocalStorage() {
            if (confirm('Are you sure you want to clear all local storage data?')) {
                localStorage.clear();
                showMessage('Local storage cleared', 'success');
            }
        }

        function resetApp() {
            if (confirm('Are you sure you want to reset the app? This will clear all data and reload the page.')) {
                localStorage.clear();
                location.reload();
            }
        }

        function setGoogleSheetsCredentials() {
            // Check if credentials are already set
            const existingSpreadsheetId = localStorage.getItem('googleSheets_spreadsheetId');
            if (existingSpreadsheetId) {
                const confirm = window.confirm('Google Sheets credentials are already set. Do you want to update them?');
                if (!confirm) {
                    showMessage('Using existing Google Sheets credentials. App is working normally.', 'info');
                    return;
                }
            }
            
            const spreadsheetUrl = prompt('Enter your Google Sheets URL or Spreadsheet ID:');
            if (spreadsheetUrl) {
                const apiKey = prompt('Enter your Google Sheets API Key (optional - leave empty for public sheets):');
                const storedWebAppUrl = localStorage.getItem('googleSheets_webAppUrl') || '';
                window.googleSheetsAPI.setCredentials(spreadsheetUrl, apiKey || '', storedWebAppUrl);
                showMessage('Google Sheets credentials set successfully', 'success');
                updateGoogleSheetsButtonStatus();
                
                // Try to auto-load data after setting credentials
                autoLoadFromGoogleSheets().catch(error => {
                    console.error('Auto-load after credential setup failed:', error);
                });
            }
        }

        function updateGoogleSheetsButtonStatus() {
            const button = document.getElementById('googleSheetsBtn');
            const existingSpreadsheetId = localStorage.getItem('googleSheets_spreadsheetId');
            
            if (existingSpreadsheetId && button) {
                button.textContent = 'Google Sheets Set ';
                button.style.backgroundColor = '#27ae60';
                button.title = 'Google Sheets is already configured. Click to change it.';
            } else if (button) {
                button.textContent = 'Set Google Sheets';
                button.style.backgroundColor = '#e74c3c';
                button.title = 'Click to set Google Sheets credentials.';
            }
        }

        async function uploadLocalDataToSheets() {
            try {
                showMessage('Uploading local data to Google Sheets...', 'info');
                
                // Get local OUT data
                const localOutData = JSON.parse(localStorage.getItem('outData') || '[]');
                if (localOutData.length === 0) {
                    showMessage('No local OUT data found to upload', 'warning');
                    return;
                }
                
                console.log(`Uploading ${localOutData.length} local OUT entries to Google Sheets`);
                
                // Check Google Sheets credentials
                const { spreadsheetId, apiKey } = window.googleSheetsAPI.getCredentials();
                if (!spreadsheetId) {
                    showMessage('Please connect to Google Sheets first using "Connect Sheets" button', 'error');
                    return;
                }
                
                if (!apiKey || apiKey.trim() === '') {
                    showMessage('Google Sheets API key is required to write data. Please add your API key in the Google Sheets section.', 'error');
                    return;
                }
                
                // Get available sheets to find OUT sheet
                const sheetNames = await window.googleSheetsAPI.getSheetNames();
                let outSheetName = sheetNames.find(name => 
                    name.toLowerCase().includes('out')
                );
                
                if (!outSheetName) {
                    // Use first sheet or create OUT sheet name
                    outSheetName = sheetNames[0] || 'OUT';
                    console.log(`No OUT sheet found, using: ${outSheetName}`);
                }
                
                // Upload data to Google Sheets
                const result = await window.googleSheetsAPI.appendToSheet(outSheetName, localOutData, false);
                
                const metaData = JSON.parse(localStorage.getItem('outDataMeta') || '{}');
                const vesselName = metaData.vesselName || 'coil-data';
                
                showMessage(`Successfully uploaded ${localOutData.length} records to Google Sheets (${outSheetName}) for vessel "${vesselName}"`, 'success');
                console.log('Upload successful:', result);
                
            } catch (error) {
                console.error('Error uploading to Google Sheets:', error);
                if (error.message.includes('API key required')) {
                    showMessage('Google Sheets API key is required for writing data. Please add your API key to enable uploads.', 'error');
                } else {
                    showMessage('Error uploading to Google Sheets: ' + error.message, 'error');
                }
            }
        }

        async function syncWithGoogleSheets() {
            try {
                showMessage('Syncing with Google Sheets...', 'info');
                
                // Load data from Google Sheets
                const sheetsData = await window.googleSheetsAPI.loadOutData();
                
                if (sheetsData && sheetsData.length > 0) {
                    // Update global outData variable only (no localStorage for multi-user app)
                    window.outData = sheetsData;
                    
                    showMessage(`Successfully synced ${sheetsData.length} records from Google Sheets`, 'success');
                    console.log('Synced data from Google Sheets:', sheetsData.length, 'records');
                } else {
                    showMessage('No data found in Google Sheets to sync', 'warning');
                }
                
            } catch (error) {
                console.error('Error syncing with Google Sheets:', error);
                showMessage('Error syncing with Google Sheets: ' + error.message, 'error');
            }
        }

        async function connectToGoogleSheets() {
            try {
                const spreadsheetId = document.getElementById('spreadsheetId').value.trim();
                const apiKey = document.getElementById('apiKey').value.trim();
                const webAppUrl = document.getElementById('webAppUrl').value.trim();
                
                if (!spreadsheetId) {
                    showMessage('Please enter a Google Sheets URL or ID', 'error');
                    return;
                }
                
                window.googleSheetsAPI.setCredentials(spreadsheetId, apiKey, webAppUrl);
                
                // Test connection
                await window.googleSheetsAPI.testConnection();
                
                let connectionStatus = 'Successfully connected to Google Sheets!';
                if (webAppUrl) {
                    connectionStatus += ' Web App URL configured for writing data.';
                } else {
                    connectionStatus += ' Note: Web App URL needed for writing data to sheets.';
                }
                
                showMessage(connectionStatus, 'success');
                
                const button = document.getElementById('connectSheetsBtn');
                if (button) {
                    button.textContent = 'Connected ';
                    button.style.backgroundColor = '#27ae60';
                }
                
            } catch (error) {
                console.error('Error connecting to Google Sheets:', error);
                showMessage('Connection failed: ' + error.message, 'error');
            }
        }

        async function loadDataFromGoogleSheets() {
            try {
                showMessage('Loading data from Google Sheets...', 'info');
                await autoLoadFromGoogleSheets();
            } catch (error) {
                console.error('Error loading data from Google Sheets:', error);
                showMessage('Error loading data: ' + error.message, 'error');
            }
        }

        function showMessage(text, type = 'info') {
            if (window.permissionManager) {
                window.permissionManager.showMessage(text, type);
            } else {
                console.log(`[${type.toUpperCase()}] ${text}`);
            }
        }

        // Test Google Apps Script connection
        async function testGoogleAppsScript() {
            try {
                const { webAppUrl } = window.googleSheetsAPI.getCredentials();
                
                if (!webAppUrl || webAppUrl.includes('YOUR_SCRIPT_ID')) {
                    showMessage('Please enter your Google Apps Script Web App URL first', 'error');
                    return;
                }
                
                showMessage('Testing Google Apps Script connection...', 'info');
                
                const response = await fetch(webAppUrl + '?test=true');
                const result = await response.json();
                
                if (result.success === false && result.error === 'No data provided') {
                    showMessage(' Google Apps Script is working correctly!', 'success');
                } else {
                    showMessage(' Google Apps Script responded successfully', 'success');
                }
                
            } catch (error) {
                console.error('Google Apps Script test failed:', error);
                showMessage(` Test failed: ${error.message}. Please check your setup.`, 'error');
            }
        }
        
        // Show setup instructions
        function showSetupInstructions() {
            const instructions = `
STEP-BY-STEP GOOGLE APPS SCRIPT SETUP:

Your script URL: https://script.google.com/home/projects/1EIK4xnwIzrV7qg6OXCEXuiejyCOuC9jdwRun6Ex3jVs336jThqmMquA-/edit

REQUIRED STEPS:
1. Click the URL above to open your Google Apps Script
2. DELETE ALL existing code in the script editor
3. PASTE this complete code:

function doGet(e) {
  return handleRequest(e);
}

function doPost(e) {
  return handleRequest(e);
}

function handleRequest(e) {
  try {
    const spreadsheetId = '18VjUGZ-dGFMEq1oIlxIssRlwkfcPZZJfH6GD7UdgOyc';
    const spreadsheet = SpreadsheetApp.openById(spreadsheetId);
    let data, sheetName;
    
    if (e.postData && e.postData.contents) {
      const formData = e.parameter;
      if (formData.payload) {
        const payload = JSON.parse(formData.payload);
        data = payload.records;
        sheetName = payload.sheetName || 'OUT';
      }
    } else if (e.parameter) {
      sheetName = e.parameter.sheetName || 'OUT';
      if (e.parameter.data) {
        data = JSON.parse(e.parameter.data);
      }
    }
    
    if (data && data.length > 0) {
      const sheet = spreadsheet.getSheetByName(sheetName);
      if (!sheet) {
        return ContentService.createTextOutput(JSON.stringify({
          success: false,
          error: "Sheet '" + sheetName + "' not found"
        })).setMimeType(ContentService.MimeType.JSON);
      }
      
      data.forEach(record => {
        const values = Object.values(record);
        sheet.appendRow(values);
      });
      
      return ContentService.createTextOutput(JSON.stringify({
        success: true,
        recordsAdded: data.length,
        message: "Data added to " + sheetName
      })).setMimeType(ContentService.MimeType.JSON);
    }
    
    return ContentService.createTextOutput(JSON.stringify({
      success: false,
      error: "No data provided"
    })).setMimeType(ContentService.MimeType.JSON);
    
  } catch (error) {
    return ContentService.createTextOutput(JSON.stringify({
      success: false,
      error: error.toString()
    })).setMimeType(ContentService.MimeType.JSON);
  }
}

4. Save the script (Ctrl+S)
5. Click "Deploy"  "New deployment" (blue button)
6. Choose "Web app" as type
7. Set "Execute as": Me (your email)  
8. Set "Who has access": Anyone
9. Click "Deploy"
10. IMPORTANT: When you see "This app isn't verified", click "Advanced" then "Go to [your script] (unsafe)"
11. Click "Allow" to grant permissions
12. Copy the Web App URL that appears
13. Test it by opening the URL in a new tab - you should see JSON response

Current status: ${window.googleSheetsAPI.getCredentials().webAppUrl ? 'URL configured' : 'URL not set'}
`;
            
            // Create a better modal dialog
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                background: rgba(0,0,0,0.8); z-index: 10000; display: flex; 
                align-items: center; justify-content: center; padding: 20px;
            `;
            
            const content = document.createElement('div');
            content.style.cssText = `
                background: #2c3e50; color: #ecf0f1; padding: 20px; 
                border-radius: 8px; max-width: 600px; max-height: 80vh; 
                overflow-y: auto; font-family: monospace; font-size: 12px;
                line-height: 1.4;
            `;
            
            content.innerHTML = `
                <h3 style="margin-top: 0;">Google Apps Script Setup</h3>
                <pre style="white-space: pre-wrap; background: #34495e; padding: 15px; border-radius: 4px; overflow-x: auto;">${instructions}</pre>
                <button onclick="this.parentElement.parentElement.remove()" 
                    style="margin-top: 15px; padding: 10px 20px; background: #3498db; 
                    color: white; border: none; border-radius: 4px; cursor: pointer;">Close</button>
            `;
            
            modal.appendChild(content);
            document.body.appendChild(modal);
        }
        
        // Open Google Apps Script directly
        function openGoogleScript() {
            const scriptUrl = 'https://script.google.com/home/projects/1EIK4xnwIzrV7qg6OXCEXuiejyCOuC9jdwRun6Ex3jVs336jThqmMquA-/edit';
            window.open(scriptUrl, '_blank');
            
            // Show quick instructions
            showMessage(' Opening your Google Apps Script. After it opens: 1) Delete all existing code, 2) Paste the new code from Setup Instructions, 3) Deploy as Web App with "Anyone" access', 'info');
        }

        // Initialize when permissions are ready
        document.addEventListener('deviceready', async () => {
            console.log('Device ready - initializing permissions');
            await window.permissionManager.initialize();
            
            // Google Drive API initialization is handled in the main device ready function
        }, false);

        // Fallback for browser testing
        if (typeof cordova === 'undefined') {
            document.addEventListener('DOMContentLoaded', async () => {
                console.log('Browser mode - initializing permissions');
                await window.permissionManager.initialize();
                
                // Google Drive API initialization is handled in the main device ready function
            });
        }
    </script>

    <!-- PWA Features - Single File Mode -->
    <script>
        console.log('PWA running in single file mode - service worker disabled for portability');
        // Service worker disabled to maintain single-file structure

        // Add to home screen prompt
        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            // Show install button or notification
            console.log('App can be installed');
        });

        // Handle app installation
        function installApp() {
            if (deferredPrompt) {
                deferredPrompt.prompt();
                deferredPrompt.userChoice.then((choiceResult) => {
                    if (choiceResult.outcome === 'accepted') {
                        console.log('User accepted the install prompt');
                    } else {
                        console.log('User dismissed the install prompt');
                    }
                    deferredPrompt = null;
                });
            }
        }

        // Tab switching functionality
        function switchTab(tabName) {
            // Hide all tab contents
            const tabContents = document.querySelectorAll('.tab-content');
            tabContents.forEach(content => {
                content.classList.remove('active');
            });

            // Remove active class from all tab headers
            const tabHeaders = document.querySelectorAll('.tab-header');
            tabHeaders.forEach(header => {
                header.classList.remove('active');
            });

            // Show selected tab content
            const selectedTab = document.getElementById(tabName + 'Tab');
            if (selectedTab) {
                selectedTab.classList.add('active');
            }

            // Add active class to selected tab header
            event.target.classList.add('active');
        }

        // Password verification for Google Sheets access
        function verifyAccess() {
            const password = document.getElementById('accessPassword').value;
            const correctPassword = 'AssaGwsa@0347'; // You can change this password
            
            if (password === correctPassword) {
                document.getElementById('sheetsContent').style.display = 'block';
                document.getElementById('accessPassword').style.display = 'none';
                document.querySelector('button[onclick="verifyAccess()"]').style.display = 'none';
                showMessage('Access granted to Google Sheets management', 'success');
            } else {
                showMessage('Incorrect password. Access denied.', 'error');
                document.getElementById('accessPassword').value = '';
            }
        }
    </script>
</body>
</html>